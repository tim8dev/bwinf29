\section{Erste bearbeitete Aufgabe: Kisten in Kisten in Kisten}
\subsection{Lösungsidee}
\subsubsection{Definitionen}
% TODO: reformulate:
Die Allgemeine Lösungsidee ist es, alle Möglichkeiten zu finden und daraus die kleinste und platzsparendste zu finden.
Hierfür wurde ein Algorithmus entwickelt, der die Striktordnung der Relation ``passt in'' den Kisten ausnutzt.
Zunächst werden ein paar Definitionen getroffen, um formal mit dem Problem umgehen zu können.
\begin{bem}
 Bei der Notation handelt es sich um die ``Implementierungsnähere''.
 Das heißt ich schreibe - objektorientiert - oft $objekt.attribut$ statt - mathematisch - $attribut(objekt)$.
 Dies finde ich intuitiver. Zum einen, weil dies meist tatsächlich schon der Code ist.
 Zum anderen, weil ich damit explizit ausdrücken kann, dass es sich um ein Teil des Objektes handelt.
\end{bem}
Ein Karton lässt sich als Tripel darstellen, wie die Aufgabe vorschreibt. Um besser mit diesen Tupeln umgehen zu können,
ordne ich die Elemente. Ich präzisiere dies formal:
\begin{defi}[Kiste] \hfill
\begin{enumerate}
 \item Die Funktion $k: {\N^+}^3 \to {\N^+}^3$ bildet Tripel der Form $(i,j,k)$ auf ein Tripel $(a,b,c)$ ab, wobei $\{i,j,k\} = \{a,b,c\}$ und $a \geq b \geq c$.
 \item Eine \emph{Kiste} k ist eine Menge von Tripeln $\{t_1, t_2, \dots, t_n\}$ mit $k(t_i) = (a,b,c)$ für alle $i \in \{1,\dots,n\}$, wobei $a,b,c \in \N^+$.
 \item $\Bbbk := \{(a,b,c) \in {\N^+}^3 \mid a \geq b \geq c\}$ heißt die \emph{Menge aller Kisten}.
 %\item Die Funktion $tuples$ % TODO: TUPLES!
\end{enumerate}
\end{defi}
\begin{bem}
 Eine Kiste wird stellvertretend mit $(a,b,c)$ bezeichnet, auf dass die Menge der Tripel abgebildet wird. 
 Um die Handhabung zu vereinfachen, bezeichnet $k.a$ das größte Maß einer Kiste k, $k.b$ das zweitgrößte und $k.c$ das drittgrößte Maß. \\
 Nachfolgend sagen wir \emph{k ist Kiste}, \emph{Kiste k} oder \emph{sei k Kiste} statt $k \in \Bbbk$. 
\end{bem}
\begin{defi}[$\subset$]
Eine Kiste k \emph{passt in} einen andere Kiste l, wenn
\[ k.a \leq l.a-1 \wedge k.b \leq l.b-1 \wedge k.c \leq l.c-1 \] beziehungsweise
\[ k.a < l.a \wedge k.b < l.b \wedge k.c < l.c \] gilt.
\end{defi}
\begin{bem}
Als Kurzform wird k passt in l auch mit $k \subset l$ oder $l \supset k$ notiert.
\end{bem}
\comment {
\begin{satz}
 Die Relation $\subset$ ist eine Striktordnung.
\end{satz}
\begin{bew}
Es genügt zu zeigen,
dass die Relation transitiv, antisymmetrisch und reflexiv ist.\\
Zunächst soll die Transitivität gezeigt werden. \\
Sei $k \subset l$ und $l \subset m$. Dann gilt nach Definition:
$$k.a < l.a < m.a \vee k.b < l.b < m.b \vee k.c < l.c < m.c$$
Also gilt $k \subset m$ und damit ist $\subset$ transitiv.

Nun wird Antisymmetrie und Irreflexivität gezeigt. \\
Sei $k \subset l$. Angenommen es gelte $l \subset k$.
Dann muss sowohl $k.a < l.a$ als auch $l.a < k.a$.
Dies ist ein Widerspruch. Also gilt $\subset$ antisymmetrisch und irreflexiv.
Also ist $\subset$ eine \emph{Striktordnung}.
\end{bew}
}
\begin{defi}[Kistenvolumen]
  Es kann jeder Kiste k ein \emph{Kistenvolumen} $v := k.a \cdot k.b \cdot k.c \in \N^+$ zugeordnet werden, welches mit $k.v$ bezeichnet wird.
\end{defi}
\begin{satz}
 Seien k und l Kisten. Wenn $k.v \geq l.v$, dann kann nicht $k \subset l$ gelten.
\end{satz}
\begin{bew}
Angenommen, $k \subset l$. Dann folgt jedoch aus der Definition
\[ k.a < l.a \wedge k.b < l.b \wedge k.c < l.c \]
Dies führt wiederum zu
\[ k.a \cdot k.b \cdot k.c < l.a \cdot l.b \cdot l.c \text{ und somit (nach B.3) } k.v < l.v \]
Da dies offensichtlich ein Widerspruch ist, ist die Aussage bewiesen.
\end{bew}
\begin{koro}
Für eine nach Volumen von groß nach klein sortierte Liste $(k_1, k_2, \dots, k_n)$ von Kartons gilt also
\[ \forall i,j \in \{1,\dots,n\}: i \leq j \Rightarrow l_i \not\subset l_j \]
\end{koro}

Hilfreich ist es natürlich auch zu wissen welche Kisten noch in eine Kiste packen können, wenn diese bereits eine andere Kiste enthält.
Zunächst wird nun erstmal definiert, welche Kisten zwei aneinandergereihte Kisten umfassen können.
\begin{defi}[$\mid$]
 Seien k und l Kisten.
 Mit $k \mid l$\footnote{Gelesen ``k neben l''} sei die Menge
\begin{align*}
 \{k(k.a+l.a, k.b, k.c),k(k.a, k.b+l.a, k.c),k(k.a, k.b, k.c+l.a), \\
   k(k.a+l.b, k.b, k.c),k(k.a, k.b+l.b, k.c),k(k.a, k.b, k.c+l.b), \\
   k(k.a+l.c, k.b, k.c),k(k.a, k.b+l.c, k.c),k(k.a, k.b, k.c+l.c) \}
\end{align*}
bezeichnet. Die Kisten k und l \emph{passen gleichzeitig} in alle Kisten m mit $m \supset n$, $n \in (k | l)$
\end{defi}
\begin{satz}
 Seien k und l Kisten. Dann gilt für alle $m \in (k \mid l): m \supset k \wedge m \supset l.$
\end{satz}
\begin{bew}
 %TODO: Prove
 Tja.. Beweis kommt noch :D
\end{bew}
Auch folgende Definitionen müssen noch geschrieben werden! (U.a. KistenSatz, gepackte Kisten, etc..)
\begin{defi}[Kistenbaum]
Ein Kistenbaum ist ein Binärbaum von Kisten. (Daher ein Knoten hat entweder 0,1 oder 2 Nachfolger)
In diesem Baum gilt: Jeder Nachfolger
\end{defi}

\subsubsection{Algorithmen}
\paragraph{Bruteforce}
Die Liste wird entsprechend dem Volumen von groß nach klein sortiert.
Die Liste wird nacheinander zu Kartonsätzen kombiniert.
Eine Hilfsfunktion erzeugt aus einer Menge von Kartonsätzen durch hinzufügen einer gegebenen Kiste die Menge aller möglichen Kistensätze.
Diese werden dann weiter mit dem nächsten zu noch mehr Kistensätzen kombiniert.
Am Ende sind alle Elemente der Liste abgearbeitet. \\
Im Folgenden ist der Algorithmus in Scala Code dargestellt. Ich habe mich bewusst gegen Pseudo-Code Notation entschieden.
Der Scala Code ist meiner Meinung nach ebenso effektiv wie Pseudo-Code.
Lediglich wenige Elemente funktionaler und objektorientierter Elemente müssen dem Leser bekannt sein.\footnote{Beispielsweise sollten Sie wissen, wie foldLeft, currying, etc. funktioniert.}\\
Wichtig ist, um den Code zu verstehen, dass (satz $++<$ kiste) alle Möglichkeiten erzeugt, wie man die Kiste in einen Satz einfügen kann.
\footnote{Nähere Erläuterungen dazu später, für den Algorithmus ist dies nicht direkt relevant.}
\lstset{language=Scala}
\lstset{basicstyle=\scriptsize}
\begin{lstlisting}
  // Nacheinander die Kisten "auffalten" mit Hilfe der hilfsPacken Funktion
  def packe = (Set[KistenSatz]() /: kisten) ( hilfsPacken )
  def hilfsPacken(sätze: Set[KistenSatz], kiste: Kiste) =
    if(sätze.isEmpty)
      Set(KistenSatz(kiste :: Nil)) // KistenSatz nur mit der Kiste
    else
      (Set[KistenSatz]() /: sätze) { // Beginne mit leerer Menge
        (menge, satz) =>
         menge ++  // Füge neue Möglichkeiten der menge hinzu
         (satz ++< kiste) // Erzeugt neue Möglichkeiten
      }
\end{lstlisting}
\subparagraph{Laufzeitverhalten}
Das Laufzeitverhalten dieses Algorithmus ist fatal. Es muss im letzten Schritt eine Kiste in bis zu $(n-1)!$ Kistensätze gepackt werden.
Die Laufzeit eine Kiste in einen Kistensatz zu packen ist $O(n)$, es muss für jede Kiste des Kistensatzes Möglichkeiten erzeugt werden.
Wir erhalten also $n! + (n-1)! \cdot n + (n-2)! \cdot (n-1) + \dots + 1!2 + 1$. Sprich $O(n \cdot n!)$.
Auch wenn der worst-case meist nicht erreicht wird, beispielsweise wenn es für 40 Kisten eher $20!$ Möglichkeiten gibt,
würde die Berechnung bereits $8 \cdot 10^{15}$ Jahre brauchen.\footnote{Unter der Annahme dass das Prüfen und Hinzufügen einer Kiste in eine andere Kiste 1 ns dauert.} \\
\subparagraph{Verkürzung der Laufzeit} Eine Überlegung war, das Laufzeitverhalten durch Parallelisierung zu verkürzen.
Nach der Annahme, dass eine Operation 1 ns dauert, kann man etwa $15!$ Operationen in einer Stunde ausführen.
Sprich es können $2*(15-1)=28$ Kisten in allen Möglichkeiten gepackt werden. (Unter der Annahme es gibt etwa $x!$ Möglichkeiten für $2x$ Kisten)
Selbst bei 100 Kernen, sprich einer hundertfachen Beschleunigung\footnote{Dies wird in der Praxis nie erreicht. Es muss immer ein gewisser Overhead für Synchronisation und Sequentielle Programmabläufe ``geopfert'' werden.}
können gerade mal $17!$ Operationen ausgeführt werden. Das entspricht $2*(17-1)=32$ Kisten. Immerhin, wir können $14\%$($32/28=1.1428\dots$) mehr Kisten packen!\footnote{Ironie.} \\
Es kommt also für Frau Y. somit nicht in Frage die Packberechnung auf eine Rechnerfarm zu migrieren. (Obwohl sie durch das geschickte Packen von ihren ~30 Kisten bereits viel Geld sparen konnte!)
\subsection{Implementation}
Frau Y. Kartons haben die \emph{Wandstärke} 0,5, hierdurch verkleinert sich der Innenraum wie gefordert jeweils um 1 cm.
