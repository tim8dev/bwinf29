\lstset{language=Scala}
\chapter[Zweite bearbeitete Aufgabe: (2) Containerklamüsel]{Zweite bearbeitete Aufgabe: \newline (2) Containerklamüsel}
\minitoc
\clearpage
\section{Lösungsidee}
Zunächst lässt sich feststellen,
dass die Anordnung der Waggons zu den Containern eine bijektive Abbildung von $[1,n]$ nach $[1,n]$, sprich, eine Permutation der Menge $[1,n]$ ist.
Für die Lösung der Aufgabe werden bestimmte Eigenschaften von Permutationen verwendet. 
Die entscheidende Eigenschaft, die der von mir entwickelte Algorithmus nutzt, ist die Tatsache,
dass sich jede Permutation als Folge von disjunkten Zyklen darstellen lässt.

Was ein Zyklus ist und was er für die Aufgabe bedeutet, lässt folgende Darstellung veranschaulichen.
Hier bilden die Container $2,5,4,8,1,2$ einen Zyklus. Ausgehend von Waggonposition 1 wird der Container 2 an die Position 2 transportiert,
anschließend der dortigen Container 5 an die Position 5, usw. bis zum Container 1 an die Position 1.
Man beachte, dass die Container so ``in einem Stück'' getauscht und an die richtige Position gebracht werden können.
\lstset{basicstyle=\ttfamily}
\begin{lstlisting}
1 2 3 4 5 6 7 8 (Waggonposition)
2 5 3 8 4 6 7 1 (Containernummer)
-->
  ------>
      <--
      -------->
<--------------
\end{lstlisting}
\lstset{basicstyle=\ttfamily}
Um den Begriff eines Zyklus' genauer einzuführen, zitiere ich folgend Beutelspacher\footnote{Definitionen, Sätze und Erklärung übernommen aus Lineare Algebra, Albrecht Beutelspacher, S.174f}.
Da von Beutelspacher einige hier nicht eingeführten Begriffe verwendet wurden, habe ich diese ersetzt.
Alle eigenständigen Änderungen wurden mit doppelten geschweiften Klammern (`\{\{' und `\}\}') markiert, um Verwechslung mit den als mathematische Symbole verwendeten eckigen Klammern zu vermeiden.
Auslassungen markiere ich mit `\{\{\dots\}\}'
\vspace{1em}  \\
\textbf{Anfang Zitat}
\begin{quotation}
\{\{Sei $S_n$ die Menge aller Permutation von $[1,n]$ in sich.\}\}

Eine Permutation $\pi$\{\{$\in S_n$\}\} wird ein \emph{Zyklus} \{\{\dots\}\} genannt, falls - grob gesprochen - die Elemente, die von $\pi$ bewegt werden,
zyklisch vertauscht werden. Genauer gesagt: Eine Permutation $\pi$ heißt zyklisch,
falls es ein $i \in $\{\{$S_n$]\}\} und eine natürliche Zahl $k$ gibt, so dass die folgenden drei Bedingungen gelten:\\
(1) $\pi^k(i) = i$, \\
(2) die Elemente $i,\pi(i),\pi^2(i),\dots,\pi^{k-1}(i)$ sind paarweise verschieden, \\
(3) jedes Element, das verschieden von $i,\pi(i),\pi^2(i),\dots,\pi^{k-1}(i), \pi^k(i) (=i)$ ist, wird von $\pi$ fest gelassen.

Die kleinste natürliche Zahl $k$ mit obiger Eigenschaft wird die \emph{Länge} des Zyklus $\pi$ genannt.
Ein Zyklus der Länge $k$ heißt auch $k$-Zyklus. Wir schreiben dann \[\hspace{10em} \pi=(i\;\pi(i)\;\pi^2(i) \; \dots \;\pi^{k-1}(i)). \hspace{8em} \{\{\dots\}\}\]

\paragraph{Darstellung einer Permutation als Produkt disjunkter Zyklen.}
\emph{Jede Permutation kann als Produkt zyklischer Permutationen geschrieben werden, von denen keine zwei ein Element gemeinsam haben.}
\emph{Das heißt: Zu jedem $\pi \in S_n$ gibt es zyklische Permutationen $\zeta_1,\dots,\zeta_s \in S_n$,
so dass folgende Eigenschaften erfüllt sind: \\
 - $\pi=\zeta_1\cdot \zeta_2 \cdot \ldots \cdot \zeta_s$ \\
 - kein Element aus \{\{$[1,n]$\}\}, das \{\{\dots\}\} in $\zeta_i$ vorkommt, kommt in $\zeta_j$ vor ($i,j=1, \dots,n, i \neq j$).}
(Das bedeutet: Wenn ein Element $x \in$\{\{$[1,n]$\}\} in einem Zyklus $\zeta_i$ ``vorkommt'',
 so wird $x$ von jedem anderen Zyklus $\zeta_j \: (j \neq i)$ fest gelassen.)
\end{quotation}
\nopagebreak[4]
\textbf{Ende Zitat}
\vfill
\clearpage
Die Darstellung der Permutation als Produkt disjunkter Zyklen erweist sich als günstig,
denn nun kann das Problem in folgende zwei Teile aufgebrochen werden.

Der erste Teil der Problemlösung ist, die Container eines Zyklus' an die richtigen Stellen zu bringen.
Dies lässt sich relativ leicht realisieren, indem der Container am Anfang eines Zyklus' an die richtige Position gebracht wird,
anschließend der zweite an die richtige Position, usw., bis der Ausgangspunkt wieder erreicht ist.
Der zweite Teil besteht also darin, die Zyklenabarbeitung dort zu unterbrechen, wo eine andere beginnt.
Da nach der Abarbeitung des nächsten Zyklus' der Kran wieder an der Position ist,
wo der erste Zyklus unterbrochen wurde, kann die Abarbeitung ``einfach'' fortgesetzt werden.
Der Sinn dieser verschachtelten Zyklenunterbrechungen ist es, Leerfahrten - und andere vermeidbare Fahrten - zu vermeiden.

Etwas anders ausgedrückt:
Beginnend am Anfang eines Zyklus', können dessen Container ``in einem Stück'' an die richtige Stelle gebracht werden
 und der Kran kann anschließend wieder an die Ausgangsposition gefahren werden.
Wir werden etwas später sehen, dass dadurch tatsächlich auch immer ein optimaler Weg (zumindest innerhalb eines Zyklus) gefunden werden kann.
Durch entsprechend richtige ``Konkatenation'' bzw. ``Verschachtelung'' der Befehlsketten für die einzelnen Zyklen lässt sich immer
 ein nach dem in der Aufgabenstellung vorgegebenem Gütekriterium optimaler Weg des Krans erstellen.
Der durch Ausführung der berechneten Instruktionen abzufahrende Weg ist also minimal.
\section{Algorithmen und Datenstrukturen}
\subsection{Anmerkung zur Notation}
Zur Erläuterung mathematischer Überlegungen wird der $math-Mode$ von \TeX benutzt.
Statt beispielsweise |perm| für eine Permutation oder |cycle| für einen oben beschrieben Zyklus als Bezeichner im ``code-Mode'' benutze ich $\pi$ respektive $\zeta$ im ``math-Mode''
 für korrespondierende mathematische Überlegungen.
Es werden also die jeweils passenderen Bezeichner und Symbole verwendet.

Um den Code kompakt zu halten, werden folgende sogenannte ``type aliases'' verwendet.

\hspace{2em}\begin{tabular}{ll}
 |Cycle|  & für |List[Int]| \\
 |Cycles| & für |List[Cycle]| \\
\end{tabular}
\subsection{Datenstrukturen}
\subsubsection{Permutation}
Permutationen auf $[1,n]$ können in einer indexierten Liste jeder Art, beispielsweise einem Array, gespeichert werden.
Da in der Informatik jedoch indexierte Listen (insbesondere Arrays) meist Indizes aus $[0,n[$ besitzen muss dies geeignet beachtet werden.
Der Definitionsbereich ist also um eins ``nach links'' verschoben.
Zur Darstellung einer Permutation im Code wird |perm: Seq[Int]| benutzt, also eine Sequenz (z. B. |Array| oder |List|) von Zahlen benutzt.
Um die Zahl |p| zu finden, auf die |i| durch |perm| abgebildet wird, gilt |p = perm(i-1)| und nicht |p = perm(i)|.
\subsubsection{Gleis}
Es wird außerdem noch eine Datenstruktur benötigt, um das Gleis mit Containerstellplätzen und Waggons abzubilden.
Hierfür werden zwei Arrays verwaltet, die zu jedem Index den Container speichern, der auf dem Containerstellplatz bzw. dem Waggon steht.
Auch hier sind die Indizes um ``eins nach links'' verschoben.
Die Implementierung dieser Datenstruktur wird in \ref{gleis} genauer erläutert.
\subsubsection{Kraninstruktionen}
Es gibt mehrere Befehle, die ein Kran nach der Aufgabenstellung ausführen kann.
Ich verwende die folgenden sieben \emph{Kraninstruktionen}.

\begin{center}
\begin{tabular}{ll}
 \textbf{PutCon} & Ablegen des Containers auf den Containerstellplatz unter dem Kran \\
 \textbf{PutWag} & Ablegen des Containers auf den Waggon unter dem Kran \\
 \textbf{TakeCon} & Aufnehmen des Containers von dem Containerstellplatz unter dem Kran \\
 \textbf{TakeWag} & Aufnehmen des Containers von dem Waggon unter dem Kran \\
 \textbf{Rotate} & Drehen des Krankopfes: \\
                 & Die aufgehobenen Container werden jeweils auf die andere Seite gedreht. \\
 \textbf{MoveRight(x)} & Bewegen des Kranes in Richtung Gleisende um x Positionen \\
 \textbf{MoveLeft(x)}  & Bewegen des Kranes in Richtung Gleisanfang um x Positionen \\
\end{tabular}
\end{center}

Seinen $x,y$ zwei beliebige Indizes dann können die Befehle |MoveRight| bzw. |MoveLeft| zusammengefasst mit |Move(x -> y)| dargestellt werden.
Wenn $x < y$ so stellt dies ein |MoveRight| dar, bei $x >= y$ ein |MoveLeft|.
Gelesen werden kann |Move(x -> y)| als ``bewege Kran von x nach y''.

\subsection{Ergebnisoptimaler Algorithmus}
\label{slow_cycler}
In diesem Abschnitt wird zunächst ein Algorithmus entworfen, der optimale Ergebnisse (im Sinne von kürzesten Kranwegen) berechnet (\ref{slow_cycler_entwurf}).
Danach wird die Optimalität bewiesen (\ref{opt_res}) und anschließend wird das Laufzeitverhalten dieses Algorithmus betrachtet, welches gut, jedoch nicht bestmöglich ist (\ref{slow}).
Im nächsten Abschnitt \ref{fast_cycler} wird ein Algorithmus vorgestellt, der sowohl optimale Ergebnisse berechnet, als auch optimale Laufzeitkomplexität vorweist.
\subsubsection{Entwurf}
\label{slow_cycler_entwurf}
\paragraph{Finden eines Zyklus'}
Der Entwurf dieses Algorithmus' ergibt sich aus der Lösungsidee. Zunächst wird die Zerlegung in disjunkte Zyklen berechnet.
Hierfür wird folgende Hilfsfunktion |cycle| zur Berechnung \emph{eines} Zyklus' verwendet.\\
Salopp gesagt, hangelt man sich so lange - bei einem Startindex beginnend - durch die Permutation, bis man wieder beim Anfangswert ankommt.
Genauer betrachtet, liefert die Unterfunktion |step| die verbleibenden Zahlen des Zyklus' hinter |idx| als Liste.
Die Unterfunktion |step| bricht mit der leeren Liste ab, wenn |start| wieder erreicht wird.
Andernfalls reiht |step| den aktuellen Wert |idx| vor die restlichen - rekursiv durch |step| - berechneten Zahlen.
Die Funktion |cycle| braucht nur mehr |step| mit |start| aufzurufen.
\lstset{basicstyle=\ttfamily}
\begin{lstlisting}
def cycle(perm: Seq[Int], start: Int): Cycle = {
  def step(idx: Int): List[Int] =
    if(start == idx) Nil
    else idx :: step(perm(idx - 1))
  step(start)
}
\end{lstlisting}
Das Ergebnis von |cycle| ist also ein Zyklus der oben beschrieben Form $(i \pi(i) \pi^2(i) \dots \pi^{k-1}(i))$ dargestellt
als |start :: perm(start-1) :: perm(perm(start-1)-1) :: |\dots| :: Nil|.
Wichtig ist hierbei zu beachten, dass die Waggonnummer, auf den der Container an der Stelle |idx| gebracht werden muss,
 durch |perm(idx-1)| dargestellt wird.
\paragraph{Finden aller Zyklen}
Nun lässt sich auch recht einfach ein Algorithmus zum Finden der disjunkten Zyklen einer Permutation angeben.
Die folgend dargestellte rekursive Funktion |cyclesOf| liefert eine Liste von disjunkten Zyklen (also eine Liste von Listen von Zahlen)
die die Permutation darstellen. Um disjunkte Zyklen zu finden, müssen jeweils alle bisher abgearbeiteten Zahlen gespeichert werden.
Dies erfolgt in einem |Set| (standardmäßig ein |HashSet| in Scala).

In jedem Rekursionsschritt wird zunächst mit |find| der neue Startwert gesucht.
Dieser ist die kleinste Zahl von |1| bis |perm.length| die noch nicht abgearbeitet wurde, also die nicht in |handled| enthalten ist.
Wurde ein Startwert |start| gefunden, dann wird anschließend der neue Zyklus |newCycle| mit der Hilfsfunktion |cycle| berechnet.
Zudem wird die neue Menge aller abgearbeiteten Zahlen |newHandled| gebildet, indem alle Zahlen aus |newCycle| in |handled| eingefügt werden.
Zuletzt erfolgt der rekursive Aufruf, wobei |newCycle| vor den rekursiv berechneten Zyklen angefügt wird.
Wurde jedoch kein Startwert gefunden - was bedeutet, dass bereits alle Zahlen in einem Zyklus vorkommen - so wird die Rekursion abgebrochen.
Es wird dann die leere Liste |Nil| zurückgegeben.
\lstset{language=Scala}
\lstset{basicstyle=\ttfamily}
\begin{lstlisting}
def cyclesOf(perm: Seq[Int], handled: Set[Int]): Cycles =
  // Suchen des Startwertes, dann das Ergebnis matchen
  (1 to perm.length) find (i => !handled.contains(i)) match {
      case Some(start) => // Wenn es ein Startwert start gibt
        val newCycle = cycle(perm, start)
        val newHandled = handled ++ newCycle
        newCycle :: cyclesOf(perm, newHandled)
      case None =>        // Wenn kein Startwert gefunden wurde
        Nil
    }
\end{lstlisting}
\paragraph{Berechnung der Instruktionen}
Anhand der berechneten Zyklen wird im nächsten Schritt die Instruktionskette, also die Befehle für die Kranbewegungen, errechnet.
Hierfür wird zunächst die folgend dargestellte Methode |computeFromCycles| definiert,
welche sich einer - gleich anschließend betrachteten - weiteren Funktion |computeCycle| bedient.
Diese Funktion berechnet zunächst mit |computeCycle| die benötigten Instruktionen.
Die letzte Instruktion, die von |computeCycle| generiert wird, ist immer ein |PutWag|, dieses ist jedoch überflüssig und wird daher mit |init| gelöscht.
Da aber |computeCycle| davon ausgeht, dass vor einem Aufruf bereits ein Container aufgehoben wurde,
 muss noch ein |TakeCon| vor der Instruktionskette angehängt werden.
Außerdem soll eine Liste zurückgegeben werden, weswegen die Instruktionskette zu solch einer umgewandelt wird.
\lstset{basicstyle=\ttfamily}
\begin{lstlisting}
def computeFromCycles(cycles: Cycles): Seq[Instruction] = {
  // Lösche letzten Befehl (immer ein PutWag) mit init
  val (instrs, _) = computeCycle(cycles.head, cycles.tail).init
  TakeCon :: // Nimm den ersten Container schonmal auf
    instrs.toList // Wandel den ListBuffer in List um.
}
\end{lstlisting}
\lstset{basicstyle=\ttfamily}
Nun wird die Funktion |computeCycle| erläutert.
Im Allgemeinen soll diese Funktion für einen Zyklus |cycle| und die restlichen Zyklen |other| die Instruktionen für einen Weg liefern,
so dass alle Elemente der gegebenen Zyklen an die richtige Position gebracht werden und der Kran wieder an die Startposition gebracht wird.
Hierbei geht |computeCycle| davon aus, dass bereits der 1. Container des Zyklus' auf den Kran gehoben wurde und noch kein anderer Container des Zyklus' bewegt wurde.
Außerdem werden Container immer auf der Containerseite und nicht auf der Waggonseite des Gleises transportiert.
Das Grundprinzip des Algorithmus' ist es, dass nacheinander alle Elemente des Zyklus' abgearbeitet werden.
Dazu wird ein |foldLeft| über den Zyklus ausgeführt (vgl.\ Z.\ 17).
Damit der Kran auch wieder zum ersten Element (Startposition) zurückgefahren wird, wird dieser Startwert |first| an den Zyklus angehängt.
In jedem Schritt werden die bisherigen Instruktionen |instrs|, die verbleibenden Nachfolgerzyklen |cyclesLeft| und das vorherige Element |prev|
an die Hilfsmethode |step| übergeben (vgl.\ Z.\ 20).
Anschließend werden die durch |foldLeft| erzeugten Instruktionen und restlichen Zyklen zurück\-ge\-ge\-ben (vgl.\ Z.\ 22).

Im folgenden ist zwecks Lesbarkeit der Code dargestellt mit Deklaration aber ohne Definition der Hilfsfunktion |step| (vgl.\ Z.\ 7f).
Der Funktionsrumpf folgt später.
Außerdem wird speziell für die |step| Funktion der type-alias |Step| für das Tuple |(ListBuffer[Instruction], Cycles, Int)| benutzt.
\clearpage
\lstset{basicstyle=\ttfamily}
\begin{lstlisting}
def computeCycle(cycle: Cycle, other: Cycles):
  (ListBuffer[Instruction], Cycles) = {
  // Das maximale Element, benutzt von step
  val max = cycle.max

  type Step = (ListBuffer[Instruction], Cycles, Int)
  def step(instrs: ListBuffer[Instruction], cyclesLeft: Cycles,
           prev: Int, cur: Int): Step = [...] // Hier ausgelassen

  val erster = cycle.head
  // Beginne mit leerem ListBuffer
  // den restlichen Zyklen other sowie dem ersten Element
  val initial = (ListBuffer[Instruction](), other, erster)
  // Arbeite alle Elemente des Zyklus' ab
  val (instrs, cyclesLeft, last) =
    // foldLeft über den Zyklus; das erste Element hinten angehängt.
    (cycle.tail :+ erster).foldLeft(initial) {
      case ((instrs, cyclesLeft, prev), cur) =>
        // Die Argumente des foldLeft an step "durchreichen".
	step(instrs, cyclesLeft, prev, cur)
    }
  (instrs, cyclesLeft)
}
\end{lstlisting}
\lstset{basicstyle=\ttfamily}
\clearpage
\label{faelle}
Die Hilfsfunktion |step| unterscheidet 3 Fälle (diese sind hinter den |case|-Anweisungen in Klammern in den Kommentaren im Codeausschnitt markiert).
\begin{enumerate}
 \item Wenn das zuletzt betrachtete Element |prev| das Maximum |max| ist und es einen nächsten Zyklus |nextCycle| gibt,
       dessen erstes Element |next| eins weiter rechts von |max| bzw. |prev| ist, dann konkateniere die Zyklen entsprechend.
       Das heißt, es werden erst mit |computeCycle| die Instruktionen |cycleInstrs| für die nächsten Zyklen berechnet
       und diese anschließend angehängt. Zudem müssen ein paar wenige Instruktionen ``zwischen'' den Zyklen,
       also vor und nach |cycleInstrs| generiert werden. Anschließend wird |step| nochmals aufgerufen,
       diesmal mit den neuen Instruktionen |extraInstrs| und ohne restliche Zyklen, da diese bereits alle abgearbeitet sind.
 \item Wenn das aktuell betrachtete Element |cur| größer als das erste Element |next| des nächsten Zyklus' |nextCycle| ist,
       dann wird zunächst der nächste Zyklus abgearbeitet.
       Hierfür wird |computeCycle| mit |nextCycle| und den restlichen Zyklen |cyclesLeft.tail| aufgerufen.
       Hierbei können Zyklen ``übrig'' bleiben,
       nämlich wenn das maximale Element des Zyklus' |next| kleiner ist als das maximale Element |max| dieses Zyklus' |cycle|.
       Die möglicherweise ``übrig'' gebliebenen Zyklen |newCyclesLeft| werden zusammen mit den neuen Instruktionen wieder an |step| übergeben.
 \item Wenn weder der 1. noch der 2. Fall zutrifft, werden lediglich Instruktionen generiert,
       die den Kran von |prev| nach |cur| bewegen, den aktuellen Container auf den Waggon ablegen und dann den Container auf dem Containerstellplatz aufheben.
\end{enumerate}
Folgend ist der Scala-Code abgebildet, welcher die Hilfsfunktion |step| darstellt.
Dieser Codeausschnitt ist deutlich komplexer als die vorherigen. Deswegen wurden entsprechend Kommentare und Markierungen hinzugefügt.
\lstset{basicstyle=\ttfamily}
\begin{lstlisting}
type Step = (ListBuffer[Instruction], Cycles, Int)

def step(instrs: ListBuffer[Instruction], cyclesLeft: Cycles,
         prev: Int, cur: Int): Step =
  cyclesLeft.headOption match {
   // Gibt es einen nächsten Zyklus direkt nach diesem beginnend?
   // ===== (1) =====
   case Some(nextCycle @ (next :: _)) if prev==max && max+1==next =>
     // Wenn ja, "konkateniere" diese Zyklen.
     val (cycleInstrs, _)=computeCycle(cyclesLeft.head,cyclesLeft.tail)
     val extraInstrs = instrs ++=
       ListBuffer(PutCon, MoveRight, TakeCon) ++=
       cycleInstrs ++= ListBuffer(MoveLeft, TakeCon)
     step(extraInstrs, Nil, prev, cur)
   // Gibt es einen nächsten Zyklus und beginnt er
   // vor dem nächsten Element dieses Zyklus'?
   // ===== (2) =====
   case Some(nextCycle @ (next :: _)) if cur > next =>
     // Wenn ja, dann arbeite erst nextCycle ab.
     val (cycleInstrs, newCyclesLeft) =
       computeCycle(nextCycle, cyclesLeft.tail)
     val newInstrs = instrs ++=
       ListBuffer(Move(prev -> next), Rotate, TakeCon,
                  Rotate, PutCon, Rotate) ++= cycleInstrs
     step(newInstrs, newCyclesLeft, next, cur)
   // ===== (3) =====
   case _ =>
     // Andernfalls, fahre einfach mit der Abarbeitung fort.
     val newInstrs = instrs ++=
       ListBuffer(Move(prev -> cur), Rotate, PutWag, TakeCon)
     (newInstrs, cyclesLeft, cur)
  }
\end{lstlisting}
\lstset{basicstyle=\ttfamily}

\subsubsection{Optimale Ergebnisse}
\label{opt_res}
Dieser Algorithmus liefert bereits optimale Ergebnisse im Sinne des Güte\-kri\-ter\-iums der Aufgabenstellung.
Um dies zu zeigen, wird bewiesen, dass die Zyklen richtig gefunden werden.
\paragraph{Korrektheit von cycle}
Zunächst wird die Korrektheit der Hilfsfunktion |cycle| gezeigt.
Das heißt, wir vergewissern uns, dass |cycle| zu einer gegebenen Permutation |perm| immer den Zyklus findet, der an dem Startindex |start| beginnt.
Da ich nachfolgend nun mathematisch argumentieren möchte, ersetzte ich die Programmbezeichnungen durch mathematische Bezeichnungen.
Konkret stelle ich |perm| durch $\pi$, den gesuchten Zyklus durch $\zeta$ und |start| durch $i$ dar.
Es ist also ein Zyklus $\zeta$ der folgenden Form gesucht.
\[ \zeta = (i, \zeta(i),\zeta^2(i), \dots, \zeta^{k-i}(i)) \]
Da für alle $x$ die im Zyklus $\zeta$ enthalten sind, $\zeta(x) = \pi(x)$ gilt und genau die Elemente
\linebreak $i, \zeta(i),\zeta^2(i), \dots, \zeta^{k-i}(i)$ in $\zeta$ enthalten sind, gilt also
\[ \zeta = (i, \zeta(i),\zeta^2(i), \dots, \zeta^{k-i}(i)) = (i, \pi(i),\pi^2(i), \dots, \pi^{k-1}(i)) \]
Nun betrachten wir nochmals die Funktionsweise von |cycle| bzw.\ von |step|.
Wir behaupten zunächst, |step| liefert zu einer Zahl $j = \pi^x(i)$ mit $x \in \{0,\dots,k\}$ die Zahlen $\pi^x(i), \pi^{x+1}(i), \dots, \pi^{k-1}(i)$.
Dies machen wir uns durch Induktion über $x$ klar. Sei also $x = k$.
Dann gilt nach Definition eines Zyklus' $j = \pi^x(i) = \pi^k(i) = i$, also bricht |step| hier ab und liefert die leere Liste, was in der Tat korrekt ist.
Nun können wir annehmen, |step| liefert für ein $j = \pi^x(i)$ mit $x \leq k$ und $x > 0$ bereits die Zahlen $\pi^x(i), \pi^{x+1}(i), \dots, \pi^{k-1}(i)$.
Also zeigen wir nun, dass |step| auch für ein $l = \pi^{x-1}$ die richtigen Zahlen liefert.
|step| reiht also $l$ vor die Zahlen, die durch Aufruf von |step| mit $\pi(l) = \pi(\pi^{x-1}) = \pi^x = j$ berechnet werden.
Das ergibt genau die Zahlen $\pi^{x-1}(i), \pi^x(i), \pi^{x+1}(i), \dots, \pi^{k-1}(i)$.
Die Aussage ist somit bewiesen.
Wird nun |step| - wie in |cycle| - mit $j = \pi^0(i) = i$, also $x = 0$ aufgerufen, erhalten wir korrekterweise die Zahlen
\[ (\pi^x(i), \pi^{x+1}(i), \dots, \pi^{k-1}(i)) = (\pi^0(i), \pi^1(i), \dots, \pi^{k-1}(i)) = (i, \pi(i), \pi^2(i), \dots, \pi^{k-1}(i)) = \zeta.\]
\paragraph{Korrektheit von cyclesOf}
Im Folgenden können wir uns also der Korrektheit von |cycle| sicher sein. Nun soll die Korrektheit von |cyclesOf| gezeigt werden.
Auch hier wähle ich mathematische Symbole und Bezeichner.
Die Liste der disjunkten Zyklen, die |cyclesOf| berechnen soll, bezeichne ich mit $\zeta_1, \zeta_2, \dots, \zeta_c$, die Menge aller fertigen Elemente |handled| mit $Z$.
Wir wollen also beweisen, dass |cyclesOf| zu einer gegebenen Permutation $\pi$ und einer leeren Menge von ``fertigen'' Elementen eine Liste
von disjunkten Zyklen $\zeta_1, \zeta_2, \dots, \zeta_c$ zurückgibt, wobei $c$ die Anzahl disjunkter Zyklen ist und $x < y \Leftrightarrow \ min(\zeta_x) < min(\zeta_y)$ für alle $x,y=1 \dots c$.
Es sollen also nach Startwert sortierte Zyklen zurückgeliefert werden.
Es wird im folgenden wieder Induktion verwendet.
Im Induktionsanfang soll also gezeigt werden, dass |cyclesOf| für $Z = \zeta_1 \cup \zeta_2 \cup \dots \cup \zeta_c$ alle verbleibende Zyklen - nämlich gar keine - findet.
Da $Z$ alle Zahlen der Permutation, also $[1,n]$ enthält, kann auch keine Zahl gefunden werden, die nicht in $Z$ enthalten ist. Somit bricht der Algorithmus mit der leeren Liste ab.
Dies ist korrekt, denn es sind bereits alle Zyklen gefunden.
Nun gelte, dass |cyclesOf| für ein $x \in \{1, \dots, c\}$ und $Z = \zeta_1 \cup \zeta_2 \cup \dots \cup \zeta_{x-1} \cup \zeta_x$ die Zyklen $\zeta_{x+1}, \dots, \zeta_c$ findet.
Wir zeigen, dass dies auch für $x \rightarrow x-1$ gilt.
Zunächst wird der Wert $s \in \{1, \dots, n\}$ ($s=$|start|, $n$ ist die Länge von $\pi$) mit $s \notin Z$ gesucht.
Nun wird der neue Zyklus $\zeta_{(x-1)+1}$ berechnet. Dieser ist sicher disjunkt von den zuvor berechneten Zyklen, da er bei $s \notin Z$ beginnt.
Anschließend wird |cyclesOf| rekursiv aufgerufen, mit |handled| = $\zeta_1 \cup \dots \cup \zeta_{x-1} \cup \zeta_{x}$.
Dieser Aufruf liefert nach Induktionsannahme die Zyklen $\zeta_{x+1}, \dots, \zeta_c$.
Also werden insgesamt die Zyklen $\zeta_{x}, \zeta_{x+1}, \dots, \zeta_c$ ausgegeben.
Dass auch die Sortierung richtig ist, sieht man anhand der Tatsache, dass immer der kleinstmögliche Startwert gesucht wird.
Also ist auch dieser Algorithmus korrekt, bei Aufruf von |cyclesOf| mit $Z = \{\}$ werden nämlich die Zyklen $\zeta_1, \dots, \zeta_c$ zurückgegeben.
\paragraph{Optimalität des Ergebnisses}
Anschließend zeigen wir die Optimalität vom eigentlichem Algorithmus, die Berechnung der Kraninstruktionen.
Diese machen wir uns klar, indem wir uns erst für eine beliebige Containerkonstellation, also eine beliebige Permutation überlegen, wie ein optimaler Weg aussehen muss.
\subparagraph{Äquivalenzklassen}
Sei $\pi$ eine beliebige Permutation über $X := [1,n]$ und $Z := \{\zeta_1, \zeta_2, \dots, \zeta_d\}$ die disjunkten Zyklen, die $\pi$ darstellen.
Nun teilen wir diese Zyklen in die Äquivalenzklassen $A_1, \dots, A_a$ auf.
Die Äquivalenzklassen sollen das Intervall $[1,n]$ in disjunkte Intervalle aufteilen, die zusammen wiederum $[1,n]$ ergeben.
Für eine Äquivalenzklasse, die das Intervall $[x,y]$ darstellt, müssen alle Zyklen zwischen $x$ und $y$ liegen.
Folgend definieren wir nun unsere Äquivalenzrelation $\equiv$, die diese Eigenschaften erfüllen soll.

Seien $\eta,\theta \in Z$ zwei Zyklen der Länge $k$ bzw. $l$ der Form $e, \eta(e), \dots, \eta^{k-1}(e)$ bzw. $t, \theta(t), \dots, \theta^{l-1}(t)$.
Weiter seien $E := \{e, \eta(e), \dots, \eta^{k-1}(e)\}$ und $T := \{t, \theta(t), \dots, \theta^{l-1}(t)\}$, also jeweils die Mengen der ``bewegten'' Elemente der Zyklen.
Dann gilt die Äquivalenz wie folgt.
\[ \eta \equiv \theta\ \ \text{genau dann, wenn}\ \ [\min(E) \leq \min(T) \leq \max(E) \vee \min(T) \leq \min(E) \leq \max(T) ]^+ \]
Hierbei notiert $R^+$ die transitive Hülle von $R$.
In Worten ausgedrückt, sind zwei Zyklen genau dann äquivalent, wenn sie sich in einem oder mehreren Schritten wechselseitig überlappen.

Nun machen wir uns noch klar, dass $\equiv$ auch wirklich eine Äquivalenzrelation auf $Z$ ist.
Die Reflexivität ist einfach, sei $\eta \in Z$ Zyklus und $E := $ alle Elemente von $\eta$ (die nicht fest gelassen werden).
Dann gilt $\min(E) \leq \min(E) \leq \max(E)$, also gilt $\eta \equiv \eta$.\\
Die Symmetrie ist ebenfalls recht anschaulich, da $\equiv$ bereits symmetrisch definiert ist.\\
Die Transitivität folgt aus der Definition als transitive Hülle.\\
Die Relation $\equiv$ ist also eine Äquivalenzrelation.

Anschließend zeigen wir noch, dass die durch die Äquivalenzrelationen geformten Äquivalenzklassen auch wirklich das Intervall $[1,n]$ in
 disjunkte Intervalle aufteilen.
Seien also $A_1, \dots, A_a$ die Äquivalenzklassen, in die $\equiv$ die Zyklen aufteilt.
Nun setzen wir $\min(A)$ einer Äquivalenzklasse $A$ auf das Minimum der Menge aller Elemente der Zyklen, die $A$ enthält.
Genauso setzten wir $\max(A)$ auf das Maximum aller Elemente der Zyklen, die $A$ enthält.

Nun wollen wir uns veranschaulichen, dass für eine Äquivalenzklasse $A_x$, mit dem Minimum $a := \min(A_x)$ sowie dem Maximum $b := \max(A_x)$ Folgendes gilt:
Für jedes $i \in [a, b]$ gibt es genau einen Zyklus $\zeta \in A_x$, der diesen nicht festlässt.\\
Die Eindeutigkeit folgt aus der Disjunktheit der Zyklen. Dass der Zyklus in $A_x$ enthalten ist, lässt sich wie folgt veranschaulichen.
Sei $\theta$ der an $a$ beginnende Zyklus und $\eta$ der an $b$ endende Zyklus. Seien weiter $T,E$ die Mengen der nicht fest gelassenen Elemente von $\theta, \eta$.
Dass $\theta, \eta \in A_x$ ist klar, denn sonst wären die Minima und Maxima von $A_x$ nicht $a,b$.
Nun unterscheiden wir zwischen zwei Fällen.\\ % Hier ist kein Fehler mehr!
(1) Falls $a = \min(T) \leq \min(E) \leq \max(T)$, dann muss entweder $\zeta \equiv \theta$ oder $\zeta \equiv \eta$ gelten.
    Denn falls $i \leq \max(T)$, so gilt aber gleichzeitig $\min(T) \leq i$, also $\zeta \equiv \theta$.
    Andernfalls gilt $i > \max(T)$, also $\min(E) < i \leq \max(E) = b$. Somit gilt $\zeta \equiv \eta$.\\
(2) Andernfalls gibt es die Zyklen $\iota_1, \iota_2, \dots, \iota_j$ mit den zugehörigen Mengen $I_1, I_2, \dots, I_j$ für die Folgendes gilt.
\[ (\min(T) \leq \min(I_1) \leq \max(T)) \wedge (\min(I_1) \leq \min(I_2) \leq \max(I_1)) \wedge \dots \wedge (\min(I_j) \leq \min(E) \leq \max(I_j)) \]
Dass es diese gibt, folgt aus der Definition von $\equiv$ als transitive Hülle.
Denn gäbe es diese Zyklen ``zwischen'' $\theta$ und $\eta$ nicht, so wären diese nicht äquivalent.
Nun muss aber $i$ zwischen den Schranken von einem $\iota_y$ sein, da alle $\iota_1, \dots, \iota_j$ zusammengefasst das ganze Intervall $[a,b]$ abdecken.
Also muss auch $\zeta \equiv \iota_y$ gelten und somit $\zeta \equiv \theta$.\\
Wie haben also gezeigt, dass $\zeta \in A_x$.

Schließlich wollen wir zeigen, dass das Intervall $[1,n]$ durch die Äquivalenzklassen in disjunkte Intervalle aufgeteilt wird.
Angenommen dies wäre nicht der Fall, so müsste es eine Stelle $i$ geben, die in beiden Äquivalenzklassen enthalten sind.
Allerdings gäbe es dann in beiden Äquivalenzklassen einen Zyklus $\theta$ bzw.\ $\eta$, der diese Stelle $i$ enthält.
Die Zyklen sind jedoch nach Definition disjunkt, also ist dies ein Widerspruch.

\subparagraph{Der optimale Weg}
Was sagen uns jetzt aber die Äquivalenzklassen? Wir erinnern uns, dass diese das Intervall $[1,n]$ in disjunkte Intervalle aufteilen.
Gibt es jetzt aber mehr als eine Äquivalenzklasse, heißt das, dass es eben mehrere solche disjunkten Intervalle gibt.

Betrachtet wir nun nochmals den zunächst gewählten Problemlösungsansatz, nämlich beginnend beim ``ersten'' Zyklus alle Zyklen zu bearbeiten und bei Überschneidungen zu unterbrechen.
Aber wir haben gerade erst gezeigt, dass es eben auch Zyklen geben kann, die sich \emph{nicht} überschneiden!
Denn mit diesem Ansatz würden wir nur die erste Äquivalenzklasse abarbeiten, nämlich die, die sich überschneiden.

Deshalb muss das Ende einer Äquivalenzklasse berücksichtigt werden. (Im Code ist dies Fall (1) in der Hilfsmethode |step| von |computeCycle|).
Sobald das Ende der Äquivalenzklasse erreicht wird, muss unterbrochen werden, die nächste Äquivalenzklasse abgearbeitet werden und schließlich wieder fortgefahren werden.

Der Algorithmus erkennt das Äquivalenzklassenende korrekt. Es wird immer das bisherige Maximum $max$ aus dem aktuell bearbeiteten Zyklus $\eta$ gebildet.
Beginnt ein Zyklus $\theta$ direkt nach diesem Maximum $max$, so wird unterbrochen.
Wie man sich leicht veranschaulicht, ist das die korrekte Unterbrechung, denn wäre $\theta$ nicht aus einer anderen Äquivalenzklasse,
würde er bereits vorher durch verschachtelte Unterbrechung abgearbeitet worden sein. Es wären also vorher bereits Unterbrechungen der Abarbeitungen erfolgt.
Ist dies aber nicht der Fall, gibt es kein Zyklus, der über $max$ hinausreicht und somit sind die Zyklen $\eta$ und $\theta$ mit Sicherheit nicht äquivalent.

Nun formuliere ich einen Satz über den optimalen Weg von Zyklen.
\begin{center}
\begin{minipage}[c]{.8\textwidth}
 Der im Sinne der Aufgabenstellung \emph{optimale Weg} $w$ zu einer die Containerpositionen beschreibenden Permutation $\pi$ mit Länge $n$,
  die durch die disjunkten Zyklen $Z$ dargestellt werden kann, ist Folgender:
 Sei $a$ die Anzahl der Äquivalenzklassen, in die $Z$ durch $\equiv$ aufgeteilt wird, dann ist der optimale Weg
 \[w = a \cdot 2 + \sum_{i = 1}^{n}{\lvert i-\pi(i)\rvert}. \]
\end{minipage}
\end{center}
Dies machen wir uns wie folgt klar. Zunächst betrachte man den Ausdruck $a \cdot 2$.
Da \emph{kein} Container über diese ``Grenze'' gebracht werden muss, aber trotzdem der Kran mindestens einmal zu jeder Position gebracht werden muss, sind hier Leerfahrten nötig.
Genauer gesagt sind \emph{zwei} Leerfahrten nötig, da der Kran (mindestens) einmal hinüber und einmal zurück gebracht werden muss.
Zurück deswegen, weil er zum Schluss auf jeden Fall an der ersten Position wieder angelangen soll.
Folgend setzen wir $w_s := \sum_{i = 1}^{n}{\lvert i-\pi(i)\rvert}$.
Nach meiner Behauptung muss also die Summe der Wege innerhalb der Äquivalenzklassen genau gleich $w_s$ sein.
Da immer nur \emph{ein} Container an der Position $c$ auf einmal transportiert werden kann,
und zwar jeweils von $c$ nach $\pi(c)$ ist dieser Weg auf jeden Fall zurückzulegen, also muss $w$ auf jeden Fall größer oder gleich $w_s$ sein.
Also genügt folgend zu betrachten, dass die Summe $w_a$ der minimalen Wege innerhalb jeder Äquivalenzklasse maximal $w_s$ ist.
Angenommen, dies wäre nicht so, also $w_a > w_s$.
Dann müsste es neben den Fahrten vom Containerstellplatz zu der dazugehörigen Waggonpositionen noch mindestens eine weitere Fahrt von $x$ nach $y$ geben,
auf der kein Container ``in die richtige Richtung'' transportiert wird.
Also entweder kein Container (->Leerfahrt) oder aber ein Container der eigentlich von einem Ort $o >= x$ zum Waggon $i <= x$ gebracht werden muss.
Da jedoch alle Zyklen innerhalb einer Äquivalenzklasse ohne Leerfahrt abgearbeitet werden können,
sind neben den $a \cdot 2$ Leerfahrten zwischen Äquivalenzklassen keine weiteren Leerfahrten nötig.
Auch sind keine Fahrten in ``falsche'' Richtungen innerhalb einer Äquivalenzklasse nötig, da alle Zyklen an einem Stück abgearbeitet werden können.
Ein Container $i$ muss zudem nie über die Grenzen einer Äquivalenzklasse transportiert werden, da $\pi(i)$ auf jeden Fall in denselben Grenzen liegt.

Nun muss noch gezeigt werden, dass der Algorithmus alle Voraussetzungen erfüllt und einen optimalen Weg liefert.
Dafür müssen lediglich folgende drei Eigenschaften gezeigt werden.
\begin{enumerate}
 \item[a)] Der erzeugte Weg ist ein zusammenhängender Weg (keine Sprünge).
 \item[b)] Jeder Container wird an die richtige Position gebracht.
 \item[c)] Es werden keine ``unnötigen'' Fahrten erzeugt. \\
       (Leerfahrten innerhalb einer Äquivalenzklasse, oder Fahrten ``in die falsche Richtung'').
\end{enumerate}
Dass jeweils die richtige Instruktionen zum Drehen des Krankopfes, Ablegen und Aufnehmen von Containern erzeugt werden, wird hier nicht bewiesen.
Es geht hier ausschließlich um den optimalen Weg. Zunächst machen wir uns a)\ klar. Sei $i$ die jeweilige Position des Krans (im Code |prev|).
Dann gilt zu Beginn $i = 1$. Hier wird mit der ersten Zyklenabarbeitung begonnen. In jedem Schritt wird zwischen den drei Fällen der Hilfsfunktion |step| (\ref{faelle}) unterschieden.
Im ersten Fall gilt $i=max$ und der nächste Zyklus beginnt bei $max+1=i+1$.
Es wird zunächst die Fahrt MoveRight generiert, dann die Zyklen des nächsten Algorithmus' angehängt und schließlich wieder eine MoveLeft Fahrt generiert.
MoveRight bewegt den Kran um 1, MoveLeft um -1. Also ist der Weg hier zusammenhängend.
(Unter der Annahme, dass der Kran durch |cycleInstrs| wieder auf die Ursprungsposition bewegt wird, dies wird unten gezeigt.)
Im zweiten Fall gilt |cur| $>$ |next|. Da |nextCycle| bereits abgearbeitet worden wäre, wenn |prev| $\geq$ |cur|, gilt |prev| < |cur| < |next|.
Der nächste Zyklus überschneidet sich also mit diesem.
Auch hier ist der Weg zusammenhängend, wie man sich leicht klar macht, denn nach Ausführen von |cycleInstrs| wird der Kran wieder an die Position |next| gebracht.
Von dort kann er im nächsten Schritt durch |step| wieder weitergebracht werden.
Im dritten Fall ist es trivial, der Container wird von |prev| nach |cur| gebracht, also ist der Weg ebenfalls zusammenhängend.

Nun zeigen wir die Eigenschaft b). Hier unterscheiden wir wieder zwischen den 3 Fällen von |step|.
Außerdem nehmen wir an, dass wir in einem Schritt immer bereits den vorherigen Container aufgehoben haben, der auf |cur| gebracht werden soll.
Im ersten Fall wird der Container zunächst an der Position |max| gelassen, anschließend wird die nächste Äquivalenzklasse abgearbeitet und wieder eins nach links gefahren.
Der Kran ist dann wieder an der Position |max| und kann den Container aufnehmen und |step| neu aufrufen, jedoch ohne Nachfolgezyklen, womit der 3. Fall vorliegt.
Im zweiten Fall ist die Überlegung ähnlich. Der aktuelle Container wird bei |next| zwischengespeichert, der Kran fährt den Nachfolgezyklus ab und kommt wieder an |next| an.
Dort nimmt er den zwischengespeicherten Container wieder auf.
Es wird im Anschluss wieder |step| aufgerufen, wodurch wieder einer der drei Fälle eintritt.
Dass nicht immer Fall 2 eintritt, lässt sich daran erkennen, dass jedes Mal mindestens ein Zyklus weniger an |step| übergeben wird.
Es muss also irgendwann Fall 1 eintreten.
Im letzten Fall, dem dritten, wird der aktuelle Container auf |cur| gebracht.
Da dies genau die Stelle ist, auf die er positioniert werden muss, ist auch Eigenschaft b) gegeben.
Die Eigenschaft c) ist ebenfalls gegeben, denn in obiger Argumentation wurde bereits gezeigt, dass nur Leerfahrten erzeugt werden, die die Äquivalenzklassen verbinden.

Nun müssen lediglich die Annahmen bewiesen werden, von denen ausgegangen wurde.
Der obige Beweis ging von der Annahme aus, dass |computeCycle| immer Instruktionen erzeugt, die den Kran wieder auf die Ausgangsposition bringen.
Dies soll nun noch gezeigt werden. Da der letzte Container der abgearbeitet wird (innerhalb eines |computeCycle|-Aufrufs) |first|=|cycle.head| ist,
 und weil durch die |foldLeft|-Anweisungen der Kran zuletzt auf |cur|=|first| gebracht wird, ist der Kran wieder auf der Ausgangsposition.

Zuletzt soll noch gezeigt werden, dass ein Container nie ``auf einen anderen'' gelegt wird, sprich dass die ``Zwischenspeicherung'' funktioniert.
Nun, alle Container werden erst dann auf einen Waggon gelegt, wenn diese auf ihrer finalen Position sind.
Getauscht - wie es in der Aufgabenstellung genannt wird - muss nur im Fall 2,
also wenn bei der Abarbeitung des Elements $z$ eines Zyklus $\zeta$ bei $i$ ein neuer Zyklus $\eta$ beginnt und die Abarbeitung unterbrochen werden muss.
Zu diesem Zeitpunkt ist der Container $\eta(i)$ an der Position $i$. Der Kran kann einfach seinen bisherigen Container auf die andere Seite schwenken, den Container $\eta(i)$
aufheben und nochmals schwenken und den ursprünglichen Container wieder absetzen.
Später kommt der Kran wieder zurück und hebt den dort zwischengelagerten Container wieder auf und fährt gemäß einem weiteren |step|-Aufruf weiter.

Wir haben also bewiesen, dass der Algorithmus - und damit im Groben auch die Implementierung - optimale Ergebnisse liefert.

\subsubsection{Laufzeitverhalten}
\label{slow}
Zunächst wird das Laufzeitverhalten des Algorithmus' zum Finden der Zyklen analysiert.
|cyclesOf| berechnet in jedem Schritt den neuen Startwert |start|.
Dazu wird die Folge 1 bis zur Permutationslänge $n$ traversiert bis ein Wert gefunden wird, der noch nicht abgearbeitet - sprich in |handled| enthalten - ist.
Nimmt man an, dass das Prüfen auf Enthaltensein konstanten Zeitaufwand darstellt (beispielsweise bei Verwendung eines |HashSet|s), dann ergibt dies insgesamt eine Komplexität von $O(n)$.
Die Berechnung eines Zyklus' benötigt höchstens die Traversierung der Permutation, also ebenfalls $O(n)$.
Anschließend werden die Zahlen, die im Zyklus enthalten sind, in |handled| eingefügt. Unter der Annahme, dass wiederum ein |HashSet| verwendet wird, ergibt das eine Komplexität von $O(n)$.
Anschließend erfolgt der rekursive Aufruf. Sei $c$ die Anzahl der Zyklen, dann wird |cyclesOf| $c$-mal aufgerufen.
Die Laufzeitkomplexität zum Finden der Zyklen ist also $O(c \cdot n)$. 

Desweiteren untersuchen wir das Laufzeitverhalten von |computeFromCycles|. Wir wollen beweisen, dass |computeFromCycles| eine Laufzeitkomplexität von $O(n)$ hat.
|computeCycle| wird so oft aufgerufen, wie es Container gibt, also $c$-mal.
Betrachten wir also die Laufzeitkomplexität eines |computeCycle|-Aufrufs abzüglich rekursiver Aufrufe.
Innerhalb eines Aufrufs zu einem Zyklus $\zeta$ der Länge $z$ wird zunächst der maximal Wert $max$ berechnet.
Dies hat eine Komplexität von $O(z)$ laut Scala-Dokumentation. Dies liegt nahe, denn der Maximalwert lässt sich durch einmalige Traversierung aller Elemente berechnen.
Anschließend erfolgt der |foldLeft|-Ausdruck. Hierbei wird der Zyklus traversiert, also wird |step| $z+1$ mal aufgerufen, da das erste Element noch am Schluss angehängt ist.
Welche Komplexität hat nun |step|? Betrachtet man die 3 Fälle genauer, kommt man zu dem Schluss, dass |step| eine Komplexität von $O(1)$ hat.
Für den Fall 3 ist es trivial. Im Fall 1 wird nichts anderes gemacht, als |computeCycle| aufzurufen und eine konstante Menge an Instruktionen anzuhängen.
Anschließend wird wieder |step| aufgerufen. Wie oft kommt aber Fall 1 \emph{insgesamt} - also in allen |computeCycle|-Aufrufen zusammen - vor?
Da Fall 1 nur bei einer ``Äquivalenzklassengrenze'' vorkommt und diese danach ``auflöst'', wird er höchstens $a$-mal ausgeführt, wobei $a$ die Anzahl Äquivalenzklassen ist.
Da $a <= n$, lässt sich die Laufzeit von Fall 1 vernachlässigen, wir wollen ja eine Komplexität von $O(n)$ beweisen.
Nun betrachten wir also den Fall 2. Auch in diesem wird nicht mehr als ein |computeCycle|-Aufruf und eine konstante Anzahl Konkatenationen getätigt.
Anschließend wird ebenfalls |step| neu aufgerufen. Also betrachten wir wieder, wie oft der Fall 2 eintritt.
Er tritt immer genau dann auf, wenn eine Überschneidung von zwei Zyklen vorliegt. Diese Überschneidung wird in Fall 2 danach aufgelöst, sie wird also nur einmal als Fall 2 bearbeitet.
Im Allgemeinen gibt es jedoch bis zu $n^2$ Überschneidungen, denn es kann sein, dass sich jeder mit jedem schneidet. Daher muss dieser Fall noch genauer betrachtet werden.
Es wird nämlich ein sich überschneidender Zyklus $\zeta$ nur einmal als solcher erkannt und abgearbeitet. Das machen wir uns wie folgt klar.
Sobald ein Zyklus während der Abarbeitung eines Zyklus $\eta$ als ein sich überschneidender erkannt wird, wird für diesen ein |computeCycle|-Aufruf getätigt.
Dieser liefert neue Zyklen zurück, in denen auf keinen Fall Zyklen sind, die sich mit $\zeta$ überschneiden, da diese durch den Fall 2 ``abgefangen'' wurden.
Also werden alle Zyklen, die sich mit $\zeta$ und $\eta$ überschneiden nur bei der Abarbeitung von $\zeta$ erkannt, nicht mehr jedoch bei folgenden |step|-Aufrufen
in der Abarbeitung von $\eta$. Jeder Zyklus kann also höchstens einmal als ein sich überschneidender Zyklus erkannt werden. Somit fällt auch der Fall 2 nicht ins Gewicht.
Da wir nun gezeigt haben, dass |step| abzüglich der Fälle 1 und 2 (die ja nicht ins Gewicht fallen) eine Komplexität von $O(1)$ hat, ist klar, dass
|computeCycle| abzüglich anderer |computeCycle|-Aufrufe eine Laufzeitkomplexität von $O(z)$ hat.

Die Funktion |computeFromCycle| ruft |computeCycle| so auf, dass für jeden Zyklus ein |computeCycle|-Aufruf nötig ist. Jeder Zyklus muss schließlich abgearbeitet werden.
Sei im Folgenden $Z$ die Menge der disjunkten Zyklen, die die Permutation darstellen und $k(\zeta)$ die Länge eines Zyklus $\zeta$.
Da für jeden Zyklus $\zeta \in Z$ der Länge $z$ ein Aufruf mit $O(z)$ nötig wird, ist die Gesamtkomplexität
\[O(\sum_{i=0}^{c}{O(k(\zeta_i))})=O(O(\sum_{i=0}^{c}{k(\zeta_i)}))=O(n)\]
Das letzte Gleichheitszeichen gilt, da die Summe der Längen von allen disjunkten Zyklen genau die der Permutation ist.

Somit haben wir die Laufzeit von $O(n)$ für |computeFromCycles| und $O(c \cdot n)$ für alle Algorithmen in der Verkettung der $c$ Zyklen gezeigt.
\clearpage
\subsection{Ergebnis- und laufzeitoptimaler Algorithmus}
\label{fast_cycler}
Das Laufzeitverhalten von $O(c \cdot n)$ ist zwar bereits recht gut, da die Anzahl der Zyklen im Normalfall nicht linear mit $n$ steigen.
(Eine zufällig erzeugte Permutation mit $10^7$ Elementen hat meist weniger als 20 Zyklen).
Der Worst-case bei $n/2$ Zyklen führt jedoch zu einer Worst-case-Komplexität von $O(n^2)$.
Deshalb soll als Erweiterung die Laufzeitkomplexität weiter verringert werden.

Außerdem sind die Algorithmen, wie sie im Abschnitt \ref{slow_cycler} angegeben sind, nicht endrekursiv.
Das heißt, bei jedem rekursivem Aufruf wird ein neuer Stack-frame allokiert.
Der Speicher hat also einen hohen Speicherplatzverbrauch.
In der Praxis heißt dies, dass nur eine Rekursionstiefe von höchstens 10.000 möglich ist.
Die Entwicklung eines laufzeitoptimalen Algorithmus' betrachte ich als Erweiterung im Sinne der allgemeinen Hinweise in den Aufgaben.
Diese ist sinnvoll, denn - wie später in \ref{scalability} gezeigt -
lassen sich damit zu einer Permutation (die die Container darstellt)
mit einer Länge in der Größenordnung $10^7$ innerhalb weniger Minuten Instruktionen berechnen, die einen optimalen Weg liefern.
\subsubsection{Verbesserung}
Die Verbesserung - und Schwierigkeit - besteht darin, den bisherigen limitierenden Faktor, nämlich die Berechnung der Zyklen zu optimieren.
Außerdem müssen alle rekursiven Funktionen umgeschrieben werden, so dass der Scala-Compiler eine Tailrekursionseliminierung vornehmen kann.
Das heißt, alle rekursiven Aufrufe einer Funktion müssen der letzte Befehl einer Funktion sein.

Zunächst wurde die Funktion |cycle| auf folgenden Code optimiert. (Die |@tailrec|-Annotation weist daraufhin, dass eine Tailrekursionseliminierung durchgeführt werden kann und soll.)
\begin{lstlisting}
def cycle(perm: Seq[Int], start: Int): Cycle = {
  @tailrec def step(ready: List[Int], idx: Int): Cycle =
    if(start == idx)
      ready.reverse
    else
      step(idx :: ready, perm(idx - 1))
  (start :: step(Nil, perm(start - 1)))
}
\end{lstlisting}
Die Änderungen betreffen wesentlich die Methode |step|. Diese hat nun zwei Parameter |ready| und |idx|.
In |ready| werden alle bisherig gefundenen Elemente eines Zyklus' akkumuliert.
Bei Rekursionsabbruch muss dementsprechend die umgekehrte Liste zurückgegeben werden (vgl.\ Z.\ 4), da in einer Liste ``last in first out'' gilt.
Es soll jedoch das zuerst gefundene Element auch als erstes in der Liste stehen.
Falls die Abbruchbedingung noch nicht erreicht wurde, wird |step| aufgerufen, mit dem aktuellen Index |idx| an |ready| angefügt und dem neuem Index |perm(idx-1)|.
Im Gegensatz zum alten |cycle| wird |step| neben dem Startwert |perm(start-1)| zusätzlich noch mit der leeren Liste |Nil| aufgerufen.

Nun wurde auch |cyclesOf| optimiert, wie im nachfolgendem Codeausschnitt dargestellt. Statt in einem |Set| werden die bereits fertigen Zahlen in einem Boolean-Array dargestellt.
Der Container mit der Nummer |i| ist genau dann bereits abgehandelt, sobald |handled(i-1) == true|.
Neben der veränderten Darstellung der fertigen Zahlen werden außerdem zwei zusätzliche Parameter benutzt.
Der erste Parameter |ready| speichert ähnlich wie bei dem neuen verbessertem |cycle| die vor dem Aufruf ``gesammelten'' Ergebnisse.
In diesem Fall werden also die bereits gefundenen Zyklen akkumuliert.
Der zweite Parameter ist |prev|. Hier wird entweder der Startwert des vorherigen Zyklus' oder, falls es keinen vorherigen gibt, 0 übergeben.
Die Abbruchbedingung bleibt die gleiche, es werden jedoch die akkumulierten Ergebnisse aus |ready| - wieder wie oben bei |cycle| - nach Umkehrung der Reihenfolge zurückgegeben.
Die Suche nach dem nächsten Element ist ebenfalls abgeändert.
Es wird nicht mehr bei 1 angefangen zu suchen, sondern beim Startwert des vorherigen Zyklus' |prev| um eins nach rechts verschoben.
Denn der Startwert des vorherigen Zyklus (und auch alle davor) wurden bestimmt bereits abgearbeitet.
Auch die Suchbedingung ist anders, es wird nicht mehr auf Nichtenthaltensein geprüft, sondern ob im Array an der Stelle |i-1| nicht |true| gesetzt ist.
Außerdem müssen die neuen Zahlenwerte nicht mehr in eine Menge eingefügt werden, sondern die Elemente des Arrays an den entsprechenden Indizes müssen auf |true| gesetzt werden.
Der rekursive Aufruf erfolgt zudem als letzter Befehl,
zusätzlich werden die neuen abgearbeiteten Zyklen |aCycle :: ready| und der Startwert des Zyklus |start| übergeben.
\begin{lstlisting}
@tailrec
def cyclesOf(ready: List[Cycle], perm: Seq[Int],
	     handled: Array[Boolean], prev: Int): Cycles =
  (prev+1 to perm.length) find (i => !(handled(i-1))) match {
    case Some(start) =>
      val aCycle = cycle(perm, start)
      for (i <- aCycle)
	handled(i-1) = true
      cyclesOf(aCycle :: ready, perm, handled, start)
    case None =>
      ready.reverse
  }
\end{lstlisting}

\subsubsection{Optimale Ergebnisse}
Wie oben (in \ref{opt_res}) bereits gezeigt, können aus korrekten, sortierten Zyklen Instruktionen, die einen optimalen Weg für den Kran liefern, berechnet werden.
Deshalb muss hier lediglich noch gezeigt werden, dass der neue Algorithmus wiederum korrekte und sortierte Zyklen berechnet. 

Im Prinzip wurden nur mehrere Elemente ersetzt. Die eigentliche Logik gilt immer noch. Insofern liefern auch die neuen Funktionen die gewünschten Zyklen.
Die Änderungen wurden oben jeweils so erklärt, dass gleichzeitig die Korrektheit begründet wird.

\subsubsection{Optimale Laufzeitkomplexität}
Die Laufzeit von |cyclesOf| ist $O(n)$, wie ich folgend zeige.

Zunächst zeige ich, dass die Gesamtkomplexität aller |cycle| Aufrufe $O(n)$ ist.
Jede Zahl wird genau einmal in einen Zyklus eingefügt, da diese disjunkt sind.
Weiter zeige ich nun, dass auch die Summe aller anderen Befehle in |cyclesOf| eine Gesamtkomplexität von $O(n)$ aufweisen.
Die |for|-Schleife (vgl.\ Z.\ 7f. in |cylesOf|) wird, nach gleicher Argumentation wie oben, ebenfalls insgesamt $O(n)$-mal durchlaufen.
Der Rest sind Operationen, für die nur konstanter Zeitaufwand nötig ist. Die Laufzeitkomplexität hängt nun lediglich von der Suchfunktion ab.
Das Prüfen im Array benötigt $O(1)$ Zeit. Da die Suche immer von |prev+1| bis zum nächsten Wert |start| durchlaufen wird, der später wiederum |prev| im nächsten Aufruf von |cyclesOf| ist,
wird auch insgesamt $O(n)$-mal im Array geprüft. Insgesamt liegt also eine Laufzeitkomplexität von $O(n)$ vor.
Da auch |computeFromCycles| lineare Laufzeitkomplexität vorweisen kann, ist die Gesamtkomplexität $O(n)$.

Da jedoch jeder Container auf einen Waggon gebracht werden muss, muss für jeden Container mindestens ein Befehl erzeugt werden.
Bei $n$ Container sind dies also $n$ Befehle. Das setzt einen Algorithmus mit einer Laufzeitkomplexität von mindestens $O(n)$ voraus.
Der erstellte Algorithmus hat also \emph{optimale Laufzeitkomplexität}.

\subsubsection{Mögliche Parallelisierung}
Es wurden Überlegungen zur Parallelisierung des Algorithmus zur Berechnung der Instruktionen gemacht.
Aus Zeitgründen wurde jedoch auf eine Implementierung verzichtet.
Der Algorithmus kann pa\-ral\-le\-li\-siert werden,
indem zunächst für jeden Zyklus die Instruktionsketten parallel berechnet werden und diese nachträglich kombiniert werden.
\clearpage

\section{Implementierung}
Grob gesehen gliedert sich die Implementierung in folgende Module und Klassen.
\begin{center}
\begin{tabular}{ll}
 \textbf{Cycler} & Algorithmen zur Berechnung der Zyklen \\
 \empty          & (in den zwei Varianten |SlowCycler| und |FastCycler|)\\
 \textbf{Instructor} & Algorithmus zur Berechnung der Kraninstruktionen aus den Zyklen \\
 \textbf{Gleis} & Datenstruktur zur Verwaltung der Containerstellplätze und Waggons \\
 \textbf{Instructions} & Die Instruktionen, die dem Kran mitteilen, was ausgeführt werden muss \\
 \textbf{Maschine} & Klasse zur Simulation einer Maschine \\
 \textbf{Utils} & hilfreiche Methoden \\
 \textbf{ListBuffer} & modifizierte Variante der standardmäßigen Scala-Klasse |ListBuffer| \\
\end{tabular}
\end{center}

 In den folgenden Abschnitten werden jeweils kurz die Implementierungen erläutert.
 Der vollständige Programmtext findet sich im entsprechenden Abschnitt des Kapitels \ref{code2} ``Programmtext''.

\subsection{Cycler - Berechnung der Zyklen}
 Da beide Algorithmen zur Zyklenfindung implementiert werden, ist ein |trait| |Cycler| implementiert (vgl.\ Z.\ 8),
  welches die einzige Methode des Moduls |cyclesOf(Seq[Int]): Cycles| definiert.
 Diese soll zu einer gegebenen Permutation eine Liste von nach Startelementen sortierten Zyklen zurückgeben.
 Die Implementierung des |SlowCycler| (vgl.\ Z.\ 13) erfolgte wie in \ref{slow_cycler}, die des |FastCycler| (vgl.\ Z.\ 34) nach \ref{fast_cycler}.

\subsection{Instructor - Berechnung der Kraninstruktionen}
Im Modul |Instructor| sind Funktionen zur Berechnung der Instruktionen implementiert.
Diese gliedern sich in die extern zu benutzenden Funktionen sowie die intern benötigten Hilfsfunktionen.
Extern zu verwenden sind |compute(Seq[Int], Cycler): Seq[Instruction]| (vgl.\ Z.\ 7) zur Berechnung ausgehend von einer Permutation,
sowie |computeFromCycles(Cycles): Seq[Instruction]| (vgl.\ Z.\ 9) zur Berechnung der Liste der Instruktionen aus - meist vorher bereits berechneten - Zyklen.
Die erstere vereinfacht die Benutzung dadurch, dass nur die Permutation angegeben werden muss (die Zyklen werden dann automatisch berechnet).
Die interne Hilfsfunktion, die die eigentliche Berechnung definiert, ist |computeCycle(Cycle, Cycles): (ListBuffer[Instruction], Cycles)| (vgl.\ Z.\ 18).
Diese gibt zu einem zu bearbeitenden Startzyklus und den restlichen Zyklen eine Liste von Instruktionen und eine Liste von unbearbeiteten Zyklen zurück.

\subsection{Gleis - Speichern des Zustands}
\label{gleis}
Die Datenstruktur zum Speichern des aktuellen Status' der Container, Containerstellplätze und Waggons wird in der Klasse |Gleis| implementiert.
Ein |Gleis| verwaltet zwei Arrays der Länge $n$. Das erste Array |con| speichert die jeweilige Containernummer auf dem zugehörigen Containerstellplatz.
Das andere Array |wag| speichert die jeweilige Nummer des Containers auf einem Waggon.
Zu Beginn wird das Array |con| mit der Permutation initialisiert.
Falls |con| oder |wag| an einer Position keinen Container enthalten, wird dies durch den Wert 0 dargestellt.

Ein |Gleis| definiert Methoden zum Setzen und Aufheben - also Löschen - von Containern an einem bestimmtem Index.
Ein |Gleis| stellt \ |takeCon(Int): Int| (vgl.\ Z.\ 21)\  zum Löschen auf den Containerstellplätzen bzw.\ \ |takeWag(Int): Int| (vgl.\ Z.\ 20)\  zum Löschen auf den Waggons bereit.
Die Methoden \ |putCon((Int, Int)): Int| (vgl.\ Z.\ 23)\  und \ |putWag((Int, Int)): Int| (vgl.\ Z.\ 22)\  werden zum Setzen von Containern auf den Containerstellplätzen bzw. den Waggons bereitgestellt.
Außerdem wurde die \ |toString: String|\  Methode über\-schrie\-ben, um eine formatierte Ausgabe zu erhalten.
Die oben genannten Methoden werden zur Manipulation der Containernummern zu den jeweiligen Containerstellplätzen bzw.\ Waggons verwendet.

\subsection{Instructions - Die Anweisungen}
Es wurden mehrere Objekte implementiert, die die einzelnen Befehle darstellen.
Es wurden |TakeWag|, |TakeCon|, |PutWag| und |PutCon| also Lege- und Hebebefehle erstellt, sowie |Rotate| als Rotationsbewegung des Kranes.
Diese spielen für den Weg des Kranes keine Rolle.
Die Befehle, die den Kranweg unmittelbar beeinflussen, sind |Move| bzw. |MoveLeft| und |MoveRight|. Hierbei ist |Move| die Superklasse der beiden anderen.

\subsection{Maschine - Interpretieren der Kraninstruktionen}
Um die erzeugten Instruktionen interpretieren, also simuliert ausführen zu können, wurde die Klasse |Maschine| geschrieben.
Diese stellt eine Methode |interpret| dar, die eine Befehlskette ausführt.
Eine |Maschine| nutzt ein |Gleis|, um den Zustand zu speichern.
Außerdem wurde die Klasse so gestaltet, dass Unterklassen leicht geschrieben werden können, um beispielsweise eine echte Kransteuerung anzubinden.

\subsection{Utils - Helfende Methoden}
 Weitere Methoden, die nützlich im Rahmen des Programms sind, jedoch nicht direkt zur Implementierung der Aufgabenlösung dienen,
  wurden in das Modul |Utils| ausgelagert. Besondere Bedeutung hat die Funktion |randPerm|, die zu einer gegebenen Permutationslänge
  eine zufällige Permutation berechnet (vgl.\ Z.\ 6-19).
 Außerdem wurden auch Methoden zum Speichern der Instruktionsketten und Permutationen implementiert.

\subsection{ListBuffer - Erweiterung der Standardklasse ListBuffer}
 Um die Befehlsketten effizient erstellen zu können, wird eine Datenstruktur benötigt,
  auf der das Anhängen einer zweiten Befehlskette in konstanter Zeit implementiert werden kann.
 Anschließend muss sie beginnend bei dem zuerst eingefügtem Element der Einfügereihenfolge folgend in linearer Zeit traversierbar sein.
 Diese Bedingungen erfüllt - leider - keine Standardklasse aus der Scala-Collections API.
 Deswegen wurde die Klasse |ListBuffer| um das Anhängen eines zweiten |ListBuffer|s mit konstantem Zeitaufwand erweitert.

\clearpage
\section{Programmabläufe}
 In diesem Abschnitt sind Programmabläufe dargestellt. Diese sind einerseits Testfälle, die praktische Indizien für die Korrektheit und Optimalität liefern.
 Andererseits stellen diese auch für sich einen Erkenntnisgewinn dar, insbesondere die Spezialfälle sind hier interessant.

 Im Abschnitt \ref{aufgabenstellung} wird das Beispiel aus der Aufgabenstellung ausgeführt, anschließend werden in \ref{special_cases} Spezialfälle diskutiert.
 Darauf folgend wird in \ref{random_perms} mit zufällig erzeugten Permutationen getestet.
 Zum Schluss wird der in \ref{fast_cycler} entworfene Algorithmus auf Skalierbarkeit in der Praxis getestet (\ref{scalability}).

\paragraph{Hinweis} Die Instruktionen wurden zwecks Platzsparens abgekürzt. Die Abkürzungen sind folgende.
 \begin{center}
  \begin{tabular}{llll}
   |TC| & |TakeCon| & |TW| & |TakeWag| \\
   |PC| & |PutCon|  & |PW| & |PutWag|   \\
   |ML| & |MoveLeft|& |MR| & |MoveRight| \\
    |R| & |Rotate|  &      &      \\
  \end{tabular}
 \end{center}
\clearpage
\subsection{Beispiel aus der Aufgabenstellung}
\label{aufgabenstellung}
Folgend ist der Ablauf, der sich bei Eingabe des Beispiels aus der Aufgabenstellung ergibt, dargestellt.

In der Zeile 15 ist die anhand der Permutation ausgerechnete, mindestens benötigte Weglänge $m$ ausgegeben.
In der Zeile 16 ist die tatsächliche Weglänge $l$ ausgegeben.
\begin{lstlisting}
scala> val perm = Seq(4,3,2,1)
perm: Seq[Int] = List(4, 3, 2, 1)

scala> val verified = Utils demonstrate perm 
Time used for computing Cycles: 6
The computed Cycles are: 
  (1 4)
  (2 3)
Number of cycles: 2
The generated Instructions (shortened) are: 
 [ TC(0) : MR(1) : R(0) : TC(0) : R(0) : PC(0) : R(0) : MR(1)
 : R(0) : PW(0) : TC(0) : ML(1) : R(0) : PW(0) : TC(0) : MR(2)
 : R(0) : PW(0) : TC(0) : ML(3) : R(0) : PW(0) ] 
Time used computing Instructions: 26
1 2 3 4;(m=8)
4 3 2 1;(l=8)
-->     (1)
  -->   (1)
  <--   (1)
  ----> (2)
<------ (3)
Time used interpreting: 23
Verifying results...
verified: Boolean = true
\end{lstlisting}
 Bemerkenswert ist hier, dass der erstellte Algorithmus in diesem Fall exakt den gleichen Weg liefert wie im Beispiel der Aufgabenstellung angegeben.
 Es gibt jedoch noch verschiedene andere optimale Wege.
 Beispielsweise kann das Prüfen auf überlappende Zyklen erst beim Zurückfahren erfolgen.
 Andere Möglichkeiten für einen optimalen Weg wären die nachfolgend dargestellte Abläufe.
 Es gibt also insgesamt vier verschiedene Fahrpläne, die für das Beispiel einen optimalen Weg ergeben.
\begin{lstlisting}                   
1 2 3 4;(m=8)	1 2 3 4;(m=8)	1 2 3 4;(m=8)
4 3 2 1;(l=8)	4 3 2 1;(l=8)	4 3 2 1;(l=8)
------>	(3)	------>	(3)	---->	(2)
    <--	(1)	  <----	(2)	  <--	(1)
  <--	(1)	  -->	(1)	  -->	(1)
  -->	(1)	  <--	(1)	    -->	(1)
<----	(2)	<--	(1)	<------	(3)
\end{lstlisting}
\clearpage
\subsection{Spezialfälle}
\label{special_cases}
Nachfolgend betrachten wir einige Spezialfälle. Gezeigt werden sowohl ein kleines Beispiel mit 4 Containern, aber auch größere Beispiele mit 14 und 20 Containern.
Im nächsten Abschnitt \ref{random_perms} folgen weitere große Beispiele.
\subsubsection*{Äquivalenzklassen}
Betrachten wir folgende Permutation $\pi = (2 1) (4 3)$.
Da sich die zwei Zyklen nicht überschneiden, stellen diese jeweils eine Äquivalenzklasse dar.
Es müssen also Befehle erzeugt werden, die diese Grenzen richtig überschreitet.
Wir betrachten folgend die Ausgabe des implementierten Programms.
\begin{lstlisting}
scala> Utils demonstrate perm                
Time used for computing Cycles: 4
The computed Cycles are: 
  (1 2)
  (3 4)
Number of cycles: 2
The generated Instructions (shortened) are: 
 [ TC : MR(1) : R : PW : TC : MR(1) : R : TC : R : PC : R : MR(1)
 : R : PW : TC : ML(1) : R : PW : TC : ML(1) : ML(1) : R : PW ] 
Time used computing Instructions: 21
1 2 3 4;(m=4)
2 1 4 3;(l=6)
-->     (1)
  -->   (1)
    --> (1)
    <-- (1)
  <--   (1)
<--     (1)
Time used interpreting: 84
Gleis: 
Container: _ _ _ _
Waggons:   1 2 3 4
Verifying results...
res7: Boolean = true
\end{lstlisting}
Betrachtet man alleine die Abbildungen der Indizes auf ihre Bilder, so erkennt man, dass insgesamt 4 Weglängen gefahren werden müssen, dies ist der Wert $m$.
Allerdings sind auch zwei zusätzliche Weglängen zu fahren, denn der Kran kann sonst nicht alle Container erreichen und auf den Waggon heben.
Addiert man diese zwei Weglängen zu den anderen vier, so erhält man sechs.
Der berechnete Weg - hier der Wert $l$ - ist also optimal.
\subsubsection*{Zyklen in Zyklen in Zyklen}
Nun betrachten wir ein maximal verschachteltes Beispiel.
Es werden immer zwei Zyklen in einen größeren verschachtelt.
Bei einer Permutationslänge von 14 ist also $\pi = (1\ 14)(2\ 7)(3\ 4)(5\ 6)(8\ 13)(9\ 10)(11\ 12)$.
Der Zyklus $(1\ 14)$ enhält $(2\ 7)$ sowie $(8\ 13)$, diese wiederum jeweils zwei weitere Zyklen.
Es wird also der Baum der Zyklenschachtelung als Folge dargestellt.

Nachfolgend ist die Ausführung des Beispiels angegeben.
\begin{lstlisting}
scala> val perm = Seq(14, 7, 4, 3, 6, 5, 2, 13, 10, 9, 12, 11, 8, 1)
perm: Seq[Int] = List(14, 7, 4, 3, 6, 5, 2, 13, 10, 9, 12, 11, 8, 1)

scala> val verified = Utils demonstrate perm                        
Time used for computing Cycles: 0
The computed Cycles are: 
  (1 14)
   (2 7)
    (3 4)
    (5 6)
   (8 13)
    (9 10)
    (11 12)
Number of cycles: 7
The generated Instructions (shortened) are: 
 [ TC : MR(1) : R : TC : R : PC : R : MR(1) : R : TC : R : PC
 : R : MR(1) : R : PW : TC : ML(1) : R : PW : TC : MR(2) : R : TC
 : R : PC : R : MR(1) : R : PW : TC : ML(1) : R : PW : TC : MR(2)
 : R : PW : TC : ML(5) : R : PW : TC : MR(6) : R : TC : R : PC
 : R : MR(1) : R : TC : R : PC : R : MR(1) : R : PW : TC : ML(1)
 : R : PW : TC : MR(2) : R : TC : R : PC : R : MR(1) : R : PW
 : TC : ML(1) : R : PW : TC : MR(2) : R : PW : TC : ML(5) : R : PW
 : TC : MR(6) : R : PW : TC : ML(13) : R : PW ] 
Time used computing Instructions: 0
 1  2  3  4  5  6  7  8  9 10 11 12 13 14;(m=54)
14  7  4  3  6  5  2 13 10  9 12 11  8  1;(l=54)
--->                                     (1)
   --->                                  (1)
      --->                               (1)
      <---                               (1)
      ------>                            (2)
            --->                         (1)
            <---                         (1)
            ------>                      (2)
   <---------------                      (5)
   ------------------>                   (6)
                     --->                (1)
                        --->             (1)
                        <---             (1)
                        ------>          (2)
                              --->       (1)
                              <---       (1)
                              ------>    (2)
                     <---------------    (5)
                     ------------------> (6)
<--------------------------------------- (13)
Time used interpreting: 2
Gleis: 
Container: _ _ _ _ _ _ _ _ _  _  _  _  _  _
Waggons:   1 2 3 4 5 6 7 8 9 10 11 12 13 14
Verifying results...
verified: Boolean = true
\end{lstlisting}

Wie man sieht, ist $m = l = 54$. Dies kommt daher, weil wir unsere Zyklen bewusst als Schachtelung konstruiert haben.
Gut zu sehen ist auch, wie der Kran sich schrittweise eine Ebene tiefer in die Zyklenschachtelung arbeitet.
Bevor ein Zyklus vollständig abgearbeitet werden kann, müssen alle Zyklen innerhalb von diesen bereits abgearbeitet sein.

\subsubsection*{Identität}
Ein weiterer Spezialfall ist die Identität als Permutation. Das heißt $\pi(x) = x$ für alle $x \in \{1,\dots,n\}$.
Hierbei bildet jeder Container eine eigene Äquivalenzklasse, da keine überschneidenden Zyklen existieren.
Nachfolgend wird also die nötigte Kranfahrt für 20 bereits in der richtigen Reihenfolge auf den Containerstellplätzen liegenden Container simuliert.
\begin{lstlisting}
scala> val perm = (1 to 20) // Identität erzeugen
perm: scala.collection.immutable.Range.Inclusive
 with scala.collection.immutable.Range.ByOne =
  Range( 1,  2,  3,  4,  5,  6,  7,  8,  9, 10,
        11, 12, 13, 14, 15, 16, 17, 18, 19, 20)

scala> val verified = Utils demonstrate perm
Time used for computing Cycles: 0
The computed Cycles are: 
  (1)
  (2)
  (3)
  (4)
  (5)
  (6)
  (7)
  (8)
  (9)
  (10)
  (11)
  (12)
  (13)
  (14)
  (15)
  (16)
  (17)
  (18)
  (19)
  (20)
Number of cycles: 20
The generated Instructions (shortened) are: 
 [TC : MR(1) : R : TC : R : PC : R : MR(1) : R : TC : R : PC
 : R : MR(1) : R : TC : R : PC : R : MR(1) : R : TC : R : PC
 : R : MR(1) : R : TC : R : PC : R : MR(1) : R : TC : R : PC
 : R : MR(1) : R : TC : R : PC : R : MR(1) : R : TC : R : PC
 : R : MR(1) : R : TC : R : PC : R : MR(1) : R : TC : R : PC
 : R : MR(1) : R : TC : R : PC : R : MR(1) : R : TC : R : PC
 : R : MR(1) : R : TC : R : PC : R : MR(1) : R : TC : R : PC
 : R : MR(1) : R : TC : R : PC : R : MR(1) : R : TC : R : PC
 : R : MR(1) : R : TC : R : PC : R : MR(1) : R : TC : R : PC
 : R : MR(1) : R : TC : R : PC : R
 : ML(0) : R : PW : TC : ML(1) : ML(0) : R : PW : TC : ML(1) 
 : ML(0) : R : PW : TC : ML(1) : ML(0) : R : PW : TC : ML(1)
 : ML(0) : R : PW : TC : ML(1) : ML(0) : R : PW : TC : ML(1)
 : ML(0) : R : PW : TC : ML(1) : ML(0) : R : PW : TC : ML(1)
 : ML(0) : R : PW : TC : ML(1) : ML(0) : R : PW : TC : ML(1)
 : ML(0) : R : PW : TC : ML(1) : ML(0) : R : PW : TC : ML(1)
 : ML(0) : R : PW : TC : ML(1) : ML(0) : R : PW : TC : ML(1)
 : ML(0) : R : PW : TC : ML(1) : ML(0) : R : PW : TC : ML(1)
 : ML(0) : R : PW : TC : ML(1) : ML(0) : R : PW : TC : ML(1)
 : ML(0) : R : PW : TC : ML(1) : ML(0) : R : PW ] 
Time used computing Instructions: 1
 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20;(m=0)
 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20;(l=38)
--->                                                       (1)
   --->                                                    (1)
      --->                                                 (1)
         --->                                              (1)
            --->                                           (1)
               --->                                        (1)
                  --->                                     (1)
                     --->                                  (1)
                        --->                               (1)
                           --->                            (1)
                              --->                         (1)
                                 --->                      (1)
                                    --->                   (1)
                                       --->                (1)
                                          --->             (1)
                                             --->          (1)
                                                --->       (1)
                                                   --->    (1)
                                                      ---> (1)
                                                         < (0)
                                                      <--- (1)
                                                      <    (0)
                                                   <---    (1)
                                                   <       (0)
                                                <---       (1)
                                                <          (0)
                                             <---          (1)
                                             <             (0)
                                          <---             (1)
                                          <                (0)
                                       <---                (1)
                                       <                   (0)
                                    <---                   (1)
                                    <                      (0)
                                 <---                      (1)
                                 <                         (0)
                              <---                         (1)
                              <                            (0)
                           <---                            (1)
                           <                               (0)
                        <---                               (1)
                        <                                  (0)
                     <---                                  (1)
                     <                                     (0)
                  <---                                     (1)
                  <                                        (0)
               <---                                        (1)
               <                                           (0)
            <---                                           (1)
            <                                              (0)
         <---                                              (1)
         <                                                 (0)
      <---                                                 (1)
      <                                                    (0)
   <---                                                    (1)
   <                                                       (0)
<---                                                       (1)
<                                                          (0)
Time used interpreting: 3
Gleis: 
Container:  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _
Waggons:    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
Verifying results...
verified: Boolean = true
\end{lstlisting}
Hier ist zwar $m = 0$, denn es muss kein einziger Container nach links oder rechts bewegt werden.
Allerdings gibt es $20-1=19$ Äquivalenzklassen, die ``konkateniert'' werden müssen.
In dem Optimalitätsbeweis haben wir bewiesen, dass der minimale Weg $w = a \cdot 2 + \sum_{i = 1}^{n}{\lvert i-\pi(i)\rvert}$ ist.
Da $a=20-1=19$ und $\sum_{i = 1}^{n}{\lvert i-\pi(i)\rvert} = 0$, ist $w = 19 \cdot 2 = 38$. Also ist auch der tatsächlich gefahrene Weg $l = w$, also optimal.

Außerdem bemerkenswert ist, dass die Weglänge von 38 für \emph{jede} Permutation der Länge 20 zurückgelegt werden muss.
Denn der Kran muss auf jeden Fall bis zum letzten Container und wieder zurück an die Startposition, also $2 \cdot (n-1)$ Weglängen zurücklegen, wobei $n$ die Länge der Permutation ist.

\clearpage
\subsection{Zufällig erzeugte Permutationen}
\label{random_perms}
\subsubsection*{1. Beispiel}
Ein nächstes, etwas größeres Beispiel ergibt sich aus zufälliger Erzeugung einer Permutation der Länge 20.
Die Permutation selber ist in Zeile 24 und 25 ausgegeben.
\lstset{basicstyle=\ttfamily}
\begin{lstlisting}
scala> import de.voodle.tim.bwinf.container._                                               
import de.voodle.tim.bwinf.container._

scala> val verified = Utils.demonstrate(20, print = true) 
Time used for computing Cycles: 8
The computed Cycles are: 
  (1 5 6)
  (2)
  (3 14 15 10 8 12 19 16 17 20)
  (4 9 11 18 7)
  (13)
Number of cycles: 5
The generated Instructions (shortened) are: 
 [ TC : MR(1) : R : TC : R : PC : R : ML(0) : R : PW : TC : MR(1)
 : R : TC : R : PC : R : MR(1) : R : TC : R : PC : R : MR(5)
 : R : PW : TC : MR(2) : R : PW : TC : MR(2) : R : TC : R : PC
 : R : ML(0) : R : PW : TC : MR(5) : R : PW : TC : ML(11) : R : PW
 : TC : ML(3) : R : PW : TC : MR(10) : R : PW : TC : MR(1) : R : PW
 : TC : ML(5) : R : PW : TC : ML(2) : R : PW : TC : MR(4) : R : PW
 : TC : MR(7) : R : PW : TC : ML(3) : R : PW : TC : MR(1) : R : PW
 : TC : MR(3) : R : PW : TC : ML(17) : R : PW : TC : MR(2) : R : PW
 : TC : MR(1) : R : PW : TC : ML(5) : R : PW ] 
Time used computing Instructions: 36
 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20;(m=92)
 5  2 14  9  6  1  4 12 11  8 18 19 13 15 10 17 20  7 16  3;(l=92)
--->                                                       (1)
   <                                                       (0)
   --->                                                    (1)
      --->                                                 (1)
         --------------->                                  (5)
                        ------>                            (2)
                              ------>                      (2)
                                    <                      (0)
                                    --------------->       (5)
                  <---------------------------------       (11)
         <---------                                        (3)
         ------------------------------>                   (10)
                                       --->                (1)
                           <---------------                (5)
                     <------                               (2)
                     ------------>                         (4)
                                 --------------------->    (7)
                                             <---------    (3)
                                             --->          (1)
                                                ---------> (3)
      <--------------------------------------------------- (17)
      ------>                                              (2)
            --->                                           (1)
<---------------                                           (5)
Time used interpreting: 30
Gleis: 
Container:  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _
Waggons:    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
Verifying results...
verified: Boolean = true
\end{lstlisting}
Permutationen bis zu einer Länge von 20 können wie gezeigt problemlos in der Konsole angezeigt und dargestellt werden.
Durch das gewählte - an die Aufgabenstellung angelehnte - Ausgabeformat können auch die zu fahrenden Wege gut in der Konsole dargestellt werden.
Auch die Optimalität des Weges kann leicht nachvollzogen werden.
Denn die anhand der Permutation ausgerechnete Weglänge $m$ stimmt mit der tatsächlichen Weglänge $l$ überein.
\subsubsection*{2. Beispiel}
Folgend ist nun noch die Bearbeitung einer weiteren zufälligen Permutation der Länge 20 dargestellt.
\begin{lstlisting}
scala> val verified = Utils.demonstrate(20, print = true) 
Permutation (shortened) is:
  (3 11 13 6 9 14 10 7 4 1 19 12 15 5 16 17 18 20 2 8)
Time used for computing Cycles: 0
The computed Cycles are: 
  (1 3 13 15 16 17 18 20 8 7 10)
  (2 11 19)
  (4 6 14 5 9)
  (12)
Number of cycles: 4
The generated Instructions (shortened) are: 
 [ TC : MR(1) : R : TC : R : PC : R : MR(2) : R : TC : R : PC
 : R : MR(2) : R : PW : TC : MR(6) : R : TC : R : PC : R : ML(0)
 : R : PW : TC : MR(2) : R : PW : TC : ML(9) : R : PW : TC : MR(4)
 : R : PW : TC : ML(5) : R : PW : TC : MR(7) : R : PW : TC : MR(8)
 : R : PW : TC : ML(17) : R : PW : TC : MR(1) : R : PW : TC : MR(10)
 : R : PW : TC : MR(2) : R : PW : TC : MR(1) : R : PW : TC : MR(1)
 : R : PW : TC : MR(1) : R : PW : TC : MR(2) : R : PW : TC : ML(12)
 : R : PW : TC : ML(1) : R : PW : TC : MR(3) : R : PW : TC : ML(9)
 : R : PW ] 
Time used computing Instructions: 0
 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20;(m=106)
 3 11 13  6  9 14 10  7  4  1 19 12 15  5 16 17 18 20  2  8;(l=106)
--->                                                       (1)
   ------>                                                 (2)
         ------>                                           (2)
               ------------------>                         (6)
                                 <                         (0)
                                 ------>                   (2)
            <---------------------------                   (9)
            ------------>                                  (4)
         <---------------                                  (5)
         --------------------->                            (7)
                              ------------------------>    (8)
   <---------------------------------------------------    (17)
   --->                                                    (1)
      ------------------------------>                      (10)
                                    ------>                (2)
                                          --->             (1)
                                             --->          (1)
                                                --->       (1)
                                                   ------> (2)
                     <------------------------------------ (12)
                  <---                                     (1)
                  --------->                               (3)
<---------------------------                               (9)
Time used interpreting: 2
Gleis: 
Container:  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _
Waggons:    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
Verifying results...
verified: Boolean = true
\end{lstlisting}
Auch hier ist die Optimalität gegeben, wie man an $m = l$ sieht.
Interessant zu beobachten ist, dass die minimale Weglänge nicht konstant für eine Permutationslänge ist.
Obwohl beide Permutationen die Länge 20 haben, müssen in diesem 2. Beispiel längere Wege zurückgelegt werden.
\clearpage
\subsection{Demonstration der Skalierbarkeit}
\label{scalability}
Nun soll die Skalierbarkeit demonstriert werden,
die als Erweiterung in Form von endrekursiven Funktionen und linearer Laufzeitkomplexität implementiert wurde.\\
Hierfür erzeugen wir eine zufällige Permutation mit einer Länge von $2^{22}$ (etwa 4,2 Millionen), die unsere Container darstellt.
Längere Permutation sind in der Realität nicht zu erwarten, denn wenn jeder Container nach Standard 40 Fuß lang ist, ergibt dies eine Gesamtlänge $g$ des Gleises von
 \[ g = 40 \cdot 2^{22}\ \text{Fuß} = 167.772.160\ \text{Fuß} \approx 51.137\ \text{km}. \]
Dies ist bereits deutlich länger als der Umfang der Erde am Äquator.
Anschließend werden, wie oben auch, die Instruktionen berechnet und interpretiert.
Für Demonstrationszwecke wird außerdem die benötigte Zeit für jeden Schritt berechnet.
Dies hat nicht das Ziel genaue Benchmarkwerte zu liefern, sondern vielmehr einen Anhaltspunkt für das Laufzeitverhalten darzustellen.
Hierfür wurde eine kleine Scala-Methode geschrieben welche im Modul |Utils| zu finden ist.
\begin{lstlisting}
scala> val verified = Utils.demonstrate(math.pow(2,22).toInt, false)
Time used for computing Cycles: 3784
Number of cycles: 17
Time used computing Instructions: 22682
(m=5863759046970)
(l=5863759046970)
Time used interpreting: 46230
Verifying results...
verified: Boolean = true
\end{lstlisting}
\lstset{basicstyle=\ttfamily}
Interessant ist hier die Beobachtung, dass es nur 17 Zyklen und eine Äquivalenzklasse gibt, bei einer Permutationslänge von $2^{22}$.
Insgesamt wurden 22.682 Millisekunden, also gute 22 Sekunden bzw. gut eine Drittel-Minute benötigt, um die Instruktionen zu berechnen.
Dies ist ein praktischer Beleg der oben theoretisch bewiesenen guten Laufzeitkomplexität.
Nach der Berechnung der Instruktionen wurden diese testweise interpretiert. Hierfür wurden gute 46 Sekunden benötigt.
Zum Schluss wurde außerdem verifiziert, dass jeder Container auf der richtigen Position ist.
Auch dieses Beispiel liefert einen optimalen Weg, wie man an $m = l = 5863759046970$ sieht.
Dieser Weg wäre in der Realität nur schwer zu erreichen, denn nimmt man an, dass der Kran keine Zeit für das Aufheben und Aufnehmen von Containern braucht,
 sowie pro Sekunde eine Weglänge zurücklegen kann (bei 40 Fuß Containerlänge wären das etwa 44 km/h), so ergibt sich folgende Rechnung.
\[l\ s = 5863759046970 / 3600\ h = 1628822000 / 24\ d = 67867583 / 365,25\ a = 185811,32\ a \approx 1,8 \cdot 10^{5}\ a \]
Es müsste also über \emph{hundert-achtzig-tausend} Jahre gefahren werden!
\clearpage

\section{Programmnutzung}
\lstset{basicstyle=\ttfamily}
Die Nutzung des Programms erfolgt primär über eine Scala-Console mit richtig eingestelltem Classpath.
Um dies einfach zu erreichen, empfehle ich, die Scala-Console nach Anleitung im Kapitel ``Allgemeines'' (\ref{allgemein}. \ref{start}) zu starten.
Die notwendigen Module und Klassen wurden bereits importiert, sofern nach der oben referenzierten Anleitung vorgegangen wurde.
Nachfolgend ist immer der Befehl hinter |scala> | angegeben. In den darauf folgenden Zeilen ist die Ausgabe dargestellt.
\subsection{Permutationen erzeugen}
Permutationen erzeugt man entweder durch direkte Eingabe oder man lässt eine randomisierte Permutation für eine gegebene Länge erzeugen.

Um eine Permutation direkt einzugeben, kann man einfach die Hilfsfunktionen der Scala-Bibliothek benutzen.
Man erzeugt und speichert einfach das Bild der Permutation in einer |Seq|. Die Permutation aus der Aufgabenstellung gibt man beispielsweise wie folgt ein.
\begin{lstlisting}
scala> val perm = Seq(4,3,2,1)
perm: Seq[Int] = List(4, 3, 2, 1)  
\end{lstlisting}
Zufällige Permutationen werden mit der Methode |randPerm| im Modul |Utils| unter Angaben einer Länge erzeugt.
Um eine zufällige Permutation der Länge 4 zu generieren, geht man z. B. wie folgt vor.
\begin{lstlisting}
scala> val perm = Utils randPerm 4                                                                                                 
perm: scala.collection.mutable.IndexedSeq[Int] =
  WrappedArray(4, 2, 1, 3)  
\end{lstlisting}
\subsection{Kraninstruktionen erzeugen}
Nachdem nun eine Permutation erzeugt wurde, kann die Methode |compute| des Moduls |Instructor| verwendet werden, um die Kraninstruktionen zu berechnen.
\begin{lstlisting}
scala> val instrs = Instructor compute perm
instrs: Seq[de.voodle.tim.bwinf.container.Instruction] = List(Take...
\end{lstlisting}
Es können auch - wenn man will - zunächst die Zyklen berechnet werden, mit dem schnellerem |FastCycler| oder mit dem langsameren |SlowCycler|.
Hierzu wird einfach die Methode |cyclesOf| aufgerufen. Zum Beispiel wie nachfolgend angegeben.
\begin{lstlisting}
scala> val cycles = FastCycler cyclesOf perm
cycles: de.voodle.tim.bwinf.container.Cycler.Cycles =
  List(List(1, 4), List(2, 3))

scala> val cycles = SlowCycler cyclesOf perm
cycles: de.voodle.tim.bwinf.container.Cycler.Cycles =
  List(List(1, 4), List(2, 3))
\end{lstlisting}
Anschließend können die Instruktionen auch direkt aus den Zyklen berechnet werden. Dafür ist die Methode |computeFromCycles| im Modul |Instructor| da.
\begin{lstlisting}
scala> val instrs = Instructor computeFromCycles cycles
instrs: Seq[de.voodle.tim.bwinf.container.Instruction] = List(Take...
\end{lstlisting}
\clearpage
\subsection{Simulation der Kranmaschine}
 Nun wurde bereits eine Instruktionskette |instrs| erzeugt.
 Die in der Aufgabenstellung skizzierte Maschine wurde implementiert, um die Kraninstruktionen ausführen zu können.
 Es kann natürlich auch ein eigener Interpreter geschrieben werden, der die Instruktionen interpretiert.
 Deswegen wurde in der Klasse |Maschine| extra die Methode |act(instr: Option[Instruction]): Unit| implementiert, so dass eine Unterklasse Extrafunktionen bereitstellen kann.

 Am einfachsten ist es, eine |Maschine| zu erzeugen, diese die Instruktionen ausführen zu lassen und anschließend die Ausgabe zu betrachten.

 Erzeugen der |Maschine|:
\begin{lstlisting}
scala> val maschine = new Maschine(new Gleis(perm),true)
maschine: de.voodle.tim.bwinf.container.Maschine = 
Container: 4 3 2 1
Waggons:   _ _ _ _
\end{lstlisting}
Ausführen der Instruktionen:
\begin{lstlisting}
scala> maschine interpret instrs
1 2 3 4;(m=8)
4 3 2 1;(l=8)
-->     (1)
  -->   (1)
  <--   (1)
  ----> (2)
<------ (3)
res1: de.voodle.tim.bwinf.container.Gleis = 
Container: _ _ _ _
Waggons:   1 2 3 4
\end{lstlisting}
In Scala liefert jeder Ausdruck einen Wert zurück. Da in dem obigem Aufruf der Wert jedoch keiner Variable explizit zugewiesen wird,
 wird der Wert einer generierten Variable |resX| zugewiesen, wobei |X| mit jedem solchen Aufruf inkrementiert wird.

\subsection{Zeitmessung}
Wenn die Skalierbarkeit nachvollzogen werden soll,
empfiehlt sich die Funktion |demonstrate| im Modul |Utils| auszuprobieren.
Um beispielsweise für 100.000 Container Instruktionen ausführen zu lassen und anschließend verifizieren zu lassen,
ob auch jeder Container am richtigen Platz angekommen ist, führt man folgende Befehle aus.
Die Zeitangaben sind jeweils in Millisekunden.
\begin{lstlisting}
scala> val verified = Utils.demonstrate(100000, print = false)
Time used for computing Cycles: 54
Number of cycles: 20
Time used computing Instructions: 343
(m=3338582674)
(l=3338582674)
Time used interpreting: 469
Verifying results...
verified: Boolean = true
\end{lstlisting}

\lstset{xleftmargin=-.8cm,xrightmargin=-.8cm}
\lstset{basicstyle=\ttfamily\small}
\clearpage
\section{Programmtext}
\label{code2}
Alle Quelldateien dieser Aufgabe finden sich auf der CD unter |Aufgabe2/src/|.
\clearpage\subsection{Cycler}
\begin{lstlisting}
package de.voodle.tim.bwinf.container
import annotation.tailrec

object Cycler {
  type Cycle = List[Int]
  type Cycles = List[List[Int]]
}
trait Cycler extends Function1[Seq[Int], List[List[Int]]] {
  def apply(perm: Seq[Int]) = cyclesOf(perm)
  def cyclesOf(perm: Seq[Int]): List[List[Int]]
}
import Cycler._
object SlowCycler extends Cycler {
  def cycle(perm: Seq[Int], start: Int): Cycle = {
    def step(idx: Int): Cycle = // Hilfsfunktion
      if(start == idx)
        Nil
      else
        idx :: step(perm(idx - 1))
    start :: step(perm(start-1))
  }
  def cyclesOf(perm: Seq[Int]): Cycles = cyclesOf(perm, Set())
  def cyclesOf(perm: Seq[Int], handled: Set[Int]): Cycles =
    // up to n calls; accessing Hashset O(1)
    (1 to perm.length) find (i => !handled.contains(i)) match {
      case Some(start) =>
        val newCycle = cycle(perm, start)
        val newReady = handled ++ newCycle // O(n)
        newCycle :: cyclesOf(perm, newReady)
      case None =>
        Nil
    }
}
object FastCycler extends Cycler {
  def cyclesOf(perm: Seq[Int]): Cycles =
    cyclesOf(Nil, perm, new Array[Boolean](perm.length), 0)

  @tailrec private
  def cyclesOf(ready: List[Cycle], perm: Seq[Int],
               handled: Array[Boolean], prev: Int): Cycles = // c *
    (prev+1 to perm.length) find (i => !(handled(i-1))) match { // O(i_c)
      case Some(start) =>
        val newCycle = cycle(perm, start)
        for (i <- newCycle) handled(i-1) = true
        cyclesOf(newCycle :: ready, perm, handled, start)
      case None =>
        ready.reverse // O(n)
    }
  /** Small helper function, finding one cycle. */
  private def cycle(perm: Seq[Int], start: Int): Cycle = {// O(n_c)
    @tailrec def step(ready: List[Int], idx: Int): Cycle = // O(n_c)
               if(start == idx) ready.reverse // O(1)
               else step(idx :: ready, perm(idx - 1))
    (start :: step(Nil, perm(start - 1)))
  }
}
\end{lstlisting}

\clearpage\subsection{Instructor}
\begin{lstlisting}
package de.voodle.tim.bwinf.container
import scala.annotation.tailrec
import scala.collection.mutable.tim.ListBuffer
import Cycler._ // import types.

object Instructor {
  def compute(perm: Seq[Int], cycler: Cycler = FastCycler): Seq[Instruction] =
    computeFromCycles(cycler cyclesOf perm)
  def computeFromCycles(cycles: Cycles): Seq[Instruction] =
    TakeCon :: computeCycle(cycles.head, cycles.tail, 1)._1.init.toList

  /**
   * Should be called, after a TakeCon!
   * When a cycle starts, all the containers in the cycles are supposed
   * to be on the container side.
   * Container are always transported on the Container side!
   */
  private def computeCycle(cycle: Cycle, other: Cycles,
                           prevMax: Int): (ListBuffer[Instruction], Cycles) = {
    // Where is the bound of this equivalence class?
    val max = math.max(cycle.max, prevMax)

    type Step = (ListBuffer[Instruction], Cycles, Int)
    @tailrec def step(instrs: ListBuffer[Instruction], cyclesLeft: Cycles,
                      prev: Int, cur: Int): Step =
     cyclesLeft.headOption match {
       case Some(nextCycle @ (next :: _)) if prev==max && max+1==next =>//(1)
         val (cycleInstrs, _) = computeCycle(nextCycle, cyclesLeft.tail, max)
         val extraInstrs = instrs ++=
           ListBuffer(MoveRight, Rotate, TakeCon, Rotate, PutCon, Rotate) ++=
           cycleInstrs += MoveLeft
         step(extraInstrs, Nil, prev, cur)
       case Some(nextCycle @ (next :: _)) if next < cur => // (2)
         val (cycleInstrs, newCyclesLeft) =
           computeCycle(nextCycle, cyclesLeft.tail, max)
         // Move from prev to nextCycle.head (next)
         val newInstrs = instrs ++=
           ListBuffer(Move(prev -> next), Rotate, TakeCon,
                      Rotate, PutCon, Rotate) ++=
           cycleInstrs
         step(newInstrs, newCyclesLeft, next, cur)
       case _ => // (3)
         val newInstrs = instrs ++=
           ListBuffer(Move(prev -> cur), Rotate, PutWag, TakeCon)
         (newInstrs, cyclesLeft, cur)
     }

    val erster = cycle.head
    val initial = (ListBuffer[Instruction](), other, erster)
    val (instrs, cyclesLeft, last) = (initial /: (cycle.tail :+ erster)) {
        case ((instrs, cyclesLeft, prev), cur) =>
            step(instrs, cyclesLeft, prev, cur)
      }
    (instrs, cyclesLeft)
  }
}
\end{lstlisting}

\clearpage\subsection{Gleis}
\begin{lstlisting}
package de.voodle.tim.bwinf.container

class Gleis(initCon: Seq[Int]) {
  val length = initCon.length
  private val con = Seq(initCon: _*).toArray
  private val wag = new Array[Int](length)

  private def arrTake(arr: Array[Int])(i: Int): Int = {
    val res = arr(i-1)
    arr(i-1) = 0
    res
  }
  private def arrPut(arr: Array[Int])(map: (Int, Int)) = map match {
    case (i, what) =>
      require(arr(i-1) == 0,
              "arr(i-1) at " + i + " must be 0, but is " + arr(i-1))
      arr(i-1) = what
  }

  def takeWag(i: Int) = arrTake(wag)(i)
  def takeCon(i: Int) = arrTake(con)(i)
  def putWag(map: (Int, Int)) = arrPut(wag)(map)
  def putCon(map: (Int, Int)) = arrPut(con)(map)

  private def arrString(arr: Array[Int]) = // Only print first 100
    arr take 100 map (i => if(i == 0) "_" else i.toString) mkString " "
  override def toString =
     "Container: " + arrString(con) + "\n" +
     "Waggons:   " + arrString(wag)

  // Immutable Vector copies!
  def container = Vector(con: _*)
  def waggons = Vector(wag: _*)
}
\end{lstlisting}
\clearpage\subsection{Instructions}
\begin{lstlisting}
package de.voodle.tim.bwinf.container

sealed trait Instruction {
  def len: Int = 0
  def short: String = (toString filter (_.isUpper))
}
case object TakeWag extends Instruction
case object TakeCon extends Instruction
case object PutWag extends Instruction
case object PutCon extends Instruction
case object Rotate extends Instruction
sealed trait Move extends Instruction {
  override def short: String = (toString filter (_.isUpper)) + "(" + len + ")"
}
object Move {
  def apply(len: Int): Move =
    if(len > 0) MoveRight(len)
    else        MoveLeft(-len)
  def apply(fromTo: (Int, Int)): Move = fromTo match {
    case (from,to) => Move(to - from)
  }
}
case class  MoveLeft (override val len: Int) extends Move
case class  MoveRight(override val len: Int) extends Move
object MoveLeft  extends MoveLeft(1)
object MoveRight extends MoveRight(1)
\end{lstlisting}

\clearpage\subsection{Maschine}
\begin{lstlisting}
package de.voodle.tim.bwinf.container
import annotation.tailrec

class Maschine(protected val gleis: Gleis,
                 private val print: Boolean = false) {
  import Maschine._
  private val length = gleis.length
  private val numLength = digits(length)
  private val space = " " * (numLength+1)
  private val arrow = "-" * (numLength+1)

  private def minLength =
    gleis.container.zipWithIndex.map{ case (v,i) => BigInt(((i+1)-v).abs) } sum

  def log(str: =>Any)(implicit forcePrint: Option[String] = None) =
    forcePrint match {
      case Some(force) if print => println(str + force)
      case Some(force) => println(force)
      case None if print => println(str)
      case _ => ()
    }
  
  def logInts(ints: =>Seq[Int]): String =
    (for(i <- ints) yield {
        val diff = numLength - digits(i)
        " " * diff + i
      }) mkString (" ")

  def interpret(instrs: Seq[Instruction]): Gleis = {
    log(logInts(1 to length) + ";")(Some("(m=" + minLength + ")"))
    log(logInts(gleis.container) + ";")
       (Some("(l=" + instrs.map(i => BigInt(i.len)).sum + ")"))
    interpret(instrs.toList,0,0,1)
  }
  // Attach point for further actions (for subclasses)
  protected def act(instrs: Option[Instruction]) {}
  
  @tailrec private def interpret(instrs: List[Instruction],
                                 con: Int, wag: Int, idx: Int): Gleis = {
    act(instrs.headOption)
    instrs match { // Recursivly check
      case Rotate :: xs =>
        interpret(xs,wag,con,idx)
      case TakeCon :: xs =>
        interpret(xs, gleis takeCon idx, wag, idx)
      case TakeWag :: xs =>
        interpret(xs, 0, gleis takeWag idx, idx)
      case PutCon :: xs =>
        gleis putCon (idx -> con)
        interpret(xs, 0, wag, idx)
      case PutWag :: xs =>
        gleis putWag (idx -> wag)
        interpret(xs, con, 0, idx)
      case MoveRight(len) :: xs =>
        log(space * (idx-1) + arrow * len + ">" +
            space * (length-len-idx) + " (" + len + ")")
        interpret(xs, con, wag, idx+len)
      case MoveLeft(len) :: xs =>
        log(space * (idx-1-len) + "<" + arrow * len +
            space * (length-idx) + " (" + len + ")")
        interpret(xs, con, wag, idx-len)
      case Nil => gleis // Do Nothing
    }
  }
  override def toString = gleis.toString
}
object Maschine {
  private def digits(num: Int) = (math.log10(num) + 1).floor.toInt
}
\end{lstlisting}

\clearpage\subsection{Utils}
\begin{lstlisting}
package de.voodle.tim.bwinf.container

object Utils {
  import scala.util.Random
  import scala.collection.mutable.IndexedSeq
  def randPerm(n: Int) = {
    // Make sure we don't convert it to an WrappedArray to often.
    val a: IndexedSeq[Int] = new Array[Int](n)
    // Init array // O(n)
    for (idx <- 0 until n) a(idx) = idx + 1
    // randomize array // O(n)
    for (i <- n to 2 by -1) {
      val di = Random.nextInt(i)
      val swap = a(di)
      a(di) = a(i-1)
      a(i-1) = swap
    }
    a // return array
  }

  def demonstrate(perm: Seq[Int], print: Boolean = true) = {
    val startTime = System.currentTimeMillis
    val cycles = FastCycler cyclesOf perm
    println("Time used for computing Cycles: " +
            (System.currentTimeMillis - startTime))
    if(print) {
      println("The computed Cycles are: ")
      println(cycles map (_.mkString("(", " ", ")")) mkString ("  ", "\n  ", ""))
    }
    println("Number of cycles: " + cycles.length)
    val instrs = Instructor computeFromCycles cycles
    val endTime = System.currentTimeMillis
    if(print) {
      println("The generated Instructions (shortened) are: ")
      val instrsGroups = instrs.view.take(20*12).map(_.short).grouped(12)
      println(instrsGroups.map(_.mkString(" : "))
              .mkString(" [ ", "\n : ",
                        if(instrs.lengthCompare(20*12)>0) " ..." else " ] "))
    }
    println("Time used computing Instructions: " + (endTime - startTime))
    val gleis = new Gleis(perm)
    val maschine = new Maschine(gleis, print)
    maschine interpret instrs
    println("Time used interpreting: " + (System.currentTimeMillis - endTime))
    if(print) {
      println("Gleis: ")
      println(gleis)
    }
    println("Verifying results...")
    gleis.waggons.zipWithIndex forall (xy => xy._1 == xy._2 + 1)
  }

  def demonstrate(n: Int, print: Boolean): Boolean = {
    val perm = randPerm(n)
    if(print) {
      println("Permutation (shortened) is:")
      println(perm.take(480).mkString(
          "  (", " ", if(perm.lengthCompare(480) > 1) " ..." else ")"))
    }
    demonstrate(perm, print)
  }
}
\end{lstlisting}

\clearpage\subsection{ListBuffer}
\begin{lstlisting}
package scala.collection.mutable.tim
import scala.collection.{mutable,generic,immutable}
import mutable._
import generic._
import immutable.{List, Nil, ::}

/** A `Buffer` implementation back up by a list. It provides constant time
 *  prepend and append. Most other operations are linear.
 *  @author  Tim Taubner
 *  @author  Matthias Zenger
 *  @author  Martin Odersky
 *  @version 2.8.tim
 *  [...]
 */
@serializable @SerialVersionUID(341963961353583661L)
final class ListBuffer[A]
      extends Buffer[A]
         with GenericTraversableTemplate[A, ListBuffer]
         with BufferLike[A, ListBuffer[A]]
         with Builder[A, List[A]]
         with SeqForwarder[A]
{
  override def companion: GenericCompanion[ListBuffer] = ListBuffer

  import scala.collection.Traversable

  private var start: List[A] = Nil
  private var last0: ::[A] = _
  private var exported: Boolean = false
  private var len = 0

  protected def underlying: immutable.Seq[A] = start

  /** The current length of the buffer.
   *  This operation takes constant time.
   */
  override def length = len

  // Implementations of abstract methods in Buffer

  override def apply(n: Int): A =
    if (n < 0 || n >= len) throw new IndexOutOfBoundsException(n.toString())
    else super.apply(n)

  /** Replaces element at index `n` with the new element
   *  `newelem`. Takes time linear in the buffer size. (except the
   *  first element, which is updated in constant time).
   *  @param n  the index of the element to replace.
   *  @param x  the new element.
   *  @throws Predef.IndexOutOfBoundsException if `n` is out of bounds.
   */
  def update(n: Int, x: A) {
    try {
      if (exported) copy()
      if (n == 0) {
        val newElem = new :: (x, start.tail);
        if (last0 eq start) {
          last0 = newElem
        }
        start = newElem
      } else {
        var cursor = start
        var i = 1
        while (i < n) {
          cursor = cursor.tail
          i += 1
        }
        val newElem = new :: (x, cursor.tail.tail)
        if (last0 eq cursor.tail) {
          last0 = newElem
        }
        cursor.asInstanceOf[::[A]].tl = newElem
      }
    } catch {
      case ex: Exception => throw new IndexOutOfBoundsException(n.toString())
    }
  }

  // THIS PART IS NEW (by tim8dev):

  /** Appends a single element to this buffer.
   *  This operation takes constant time.
   *  @param x  the element to append.
   *  @return   this $coll.
   */
  def += (x: A): this.type = {
    val newLast = new :: (x,Nil)
    append(newLast, newLast, 1)
  }

  override def ++=(xs: TraversableOnce[A]): this.type = xs match {
    case some : ::[A] =>
      append(some, some.last.asInstanceOf[::[A]], some.length)
    case buff : ListBuffer[A] =>
      buff.start match {
        case some : ::[A] =>
          if(buff.exported)
            buff.copy()
          buff.exported = true
          append(some, buff.last0, buff.len)
        case Nil =>
          this
      }
    case xs =>
      super.++=(xs)
  }

  private def append(x: ::[A], last: ::[A], length: Int): this.type = {
    if(exported) copy()
    if(start.isEmpty) {
      last0 = last
      start = x
    } else {
      val last1 = last0
      last1.tl = x
      last0 = last
    }
    len += length
    this
  }

  // END OF NEW PART (by tim8dev).

  /** Clears the buffer contents.
   */
  def clear() {
    start = Nil
    exported = false
    len = 0
  }

  /** Prepends a single element to this buffer. This operation takes constant
   *  time.
   *  @param x  the element to prepend.
   *  @return   this $coll.
   */
  def +=: (x: A): this.type = {
    if (exported) copy()
    val newElem = new :: (x, start)
    if (start.isEmpty) last0 = newElem
    start = newElem
    len += 1
    this
  }

  /** Inserts new elements at the index `n`. Opposed to method
   *  `update`, this method will not replace an element with a new
   *  one. Instead, it will insert a new element at index `n`.
   *  @param  n     the index where a new element will be inserted.
   *  @param  iter  the iterable object providing all elements to insert.
   *  @throws Predef.IndexOutOfBoundsException if `n` is out of bounds.
   */
  def insertAll(n: Int, seq: Traversable[A]) {
    try {
      if (exported) copy()
      var elems = seq.toList.reverse
      len += elems.length
      if (n == 0) {
        while (!elems.isEmpty) {
          val newElem = new :: (elems.head, start)
          if (start.isEmpty) last0 = newElem
          start = newElem
          elems = elems.tail
        }
      } else {
        var cursor = start
        var i = 1
        while (i < n) {
          cursor = cursor.tail
          i += 1
        }
        while (!elems.isEmpty) {
          val newElem = new :: (elems.head, cursor.tail)
          if (cursor.tail.isEmpty) last0 = newElem
          cursor.asInstanceOf[::[A]].tl = newElem
          elems = elems.tail
        }
      }
    } catch {
      case ex: Exception =>
        throw new IndexOutOfBoundsException(n.toString())
    }
  }

  /** Removes a given number of elements on a given index position. May take
   *  time linear in the buffer size.
   *  @param n         the index which refers to the first element to remove.
   *  @param count     the number of elements to remove.
   */
  override def remove(n: Int, count: Int) {
    if (exported) copy()
    val n1 = n max 0
    val count1 = count min (len - n1)
    var old = start.head
    if (n1 == 0) {
      var c = count1
      while (c > 0) {
        start = start.tail
        c -= 1
      }
    } else {
      var cursor = start
      var i = 1
      while (i < n1) {
        cursor = cursor.tail
        i += 1
      }
      var c = count1
      while (c > 0) {
        if (last0 eq cursor.tail) last0 = cursor.asInstanceOf[::[A]]
        cursor.asInstanceOf[::[A]].tl = cursor.tail.tail
        c -= 1
      }
    }
    len -= count1
  }

// Implementation of abstract method in Builder

  def result: List[A] = toList

  /** Converts this buffer to a list. Takes constant time. The buffer is
   *  copied lazily, the first time it is mutated.
   */
  override def toList: List[A] = {
    exported = !start.isEmpty
    start
  }

// New methods in ListBuffer

  /** Prepends the elements of this buffer to a given list
   *
   *  @param xs   the list to which elements are prepended
   */
  def prependToList(xs: List[A]): List[A] =
    if (start.isEmpty) xs
    else { last0.tl = xs; toList }

// Overrides of methods in Buffer

  /** Removes the element on a given index position. May take time linear in
   *  the buffer size.
   *  @param  n  the index which refers to the element to delete.
   *  @return n  the element that was formerly at position `n`.
   *  @note      an element must exists at position `n`.
   *  @throws Predef.IndexOutOfBoundsException if `n` is out of bounds.
   */
  def remove(n: Int): A = {
    if (n < 0 || n >= len) throw new IndexOutOfBoundsException(n.toString())
    if (exported) copy()
    var old = start.head
    if (n == 0) {
      start = start.tail
    } else {
      var cursor = start
      var i = 1
      while (i < n) {
        cursor = cursor.tail
        i += 1
      }
      old = cursor.tail.head
      if (last0 eq cursor.tail) last0 = cursor.asInstanceOf[::[A]]
      cursor.asInstanceOf[::[A]].tl = cursor.tail.tail
    }
    len -= 1
    old
  }

  /** Remove a single element from this buffer. May take time linear in the
   *  buffer size.
   *  @param x  the element to remove.
   *  @return   this $coll.
   */
  override def -= (elem: A): this.type = {
    if (exported) copy()
    if (start.isEmpty) {}
    else if (start.head == elem) {
      start = start.tail
      len -= 1
    } else {
      var cursor = start
      while (!cursor.tail.isEmpty && cursor.tail.head != elem) {
        cursor = cursor.tail
      }
      if (!cursor.tail.isEmpty) {
        val z = cursor.asInstanceOf[::[A]]
        if (z.tl == last0)
          last0 = z
        z.tl = cursor.tail.tail
        len -= 1
      }
    }
    this
  }

  override def iterator = new Iterator[A] {
    var cursor: List[A] = null
    def hasNext: Boolean = !start.isEmpty && (cursor ne last0)
    def next(): A =
      if (!hasNext) {
        throw new NoSuchElementException("next on empty Iterator")
      } else {
        if (cursor eq null) cursor = start else cursor = cursor.tail
        cursor.head
      }
  }

  /** expose the underlying list but do not mark it as exported */
  override def readOnly: List[A] = start

  // Private methods

  /** Copy contents of this buffer */
  private def copy() {
    var cursor = start
    val limit = last0.tail
    clear
    while (cursor ne limit) {
      this += cursor.head
      cursor = cursor.tail
    }
  }

  override def equals(that: Any): Boolean = that match {
    case that: ListBuffer[_] => this.readOnly equals that.readOnly
    case _                   => super.equals(that)
  }

  /** Returns a clone of this buffer.
   *  @return a <code>ListBuffer</code> with the same elements.
   */
  override def clone(): ListBuffer[A] = (new ListBuffer[A]) ++= this

  /** Defines the prefix of the string representation.
   *  @return the string representation of this buffer.
   */
  override def stringPrefix: String = "ListBuffer"
}

/** $factoryInfo
 *  @define Coll ListBuffer
 *  @define coll list buffer
 */
object ListBuffer extends SeqFactory[ListBuffer] {
  implicit def canBuildFrom[A]: CanBuildFrom[Coll, A, ListBuffer[A]] =
    new GenericCanBuildFrom[A]
  def newBuilder[A]: Builder[A, ListBuffer[A]] =
    new GrowingBuilder(new ListBuffer[A])
}
\end{lstlisting}