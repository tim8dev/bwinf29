\section{Zweite bearbeitete Aufgabe: (2) Containerklamüsel}
\subsection{Lösungsidee}
\subsubsection{Vorüberlegungen}
Die Anordnung der Waggons zu den Container ist eine bijektive Abbildung von $[1,n]$ nach $[1,n]$, sprich, eine Permutation der Menge $[1,n]$.
Jede Permutation lässt sich als Folge von disjunkten Zyklen darstellen. \\ %TODO: CITE!
``Eine Permutation $\pi$ einer Menge wird \emph{Zyklus} genannt, falls - grob gesprochen - die Elemente, die von $\pi$ bewegt werden,
zyklisch vertauscht werden. Genauer gesagt: Eine Permutation $\pi$ heißt zyklisch,
falls es ein $ i \in X$ und eine natürliche Zahl $k$ gibt, so dass die folgenden drei Bedingungen gelten:
\begin{enumerate}
 \item $\pi^k(i) = i$,
 \item die Elemente $i,\pi(i),\pi^2(i),\dots,\pi^{k-1}(i)$ sind paarweise verschieden,
 \item jedes Element, das verschieden von $i,\pi(i),\pi^2(i),\dots,\pi^{k-1}(i) (=i)$ ist, wird von $\pi$ fest gelassen.
\end{enumerate}
Die kleinste natürliche Zahl k mit obiger Eigenschaft wird die \emph{Länge} des Zyklus $\pi$ genannt.
Ein Zyklus der Länge k heißt auch k-Zyklus. Wir schreiben dann \[\pi=(i\;\pi(i)\;\pi^2(i) \; \dots \;\pi^{k-1}(i)).\]
[..]
\paragraph{Darstellung einer Permutation als Produkt disjunker Zyklen.}
\emph{Jede Permutation kann als Produkt zyklischer Permutationen geschrieben werden, von denen keine zwei ein Element gemeinsam haben.}\\
\emph{Das heißt: Zu jedem $\pi \in S_n$ gibt es zyklische Permutationen $\zeta_1,\dots,\zeta_s \in S_n$,
so dass folgendes Eigenschaften erfüllt sind: \\
 - $\pi=\zeta_1\cdot \zeta_2 \cdot \ldots \cdot \zeta_s$ \\
 - kein Element aus X, das als Komponente in $\zeta_i$ vorkommt, kommt in $\zeta_j$ vor ($i,j=1,\dots,n, i \neq j$).
(Das bedeuted: Wenn ein Element $x \in X$ in einem Zyklus $\zeta_i$ ``vorkommt'',
 so wird $x$ von jedem anderen Zyklus $\zeta_j \: (j \neq i)$ fest gelassen.)
}''\footnote{Definitionen, Sätze und Erklärung übernommen aus Lineare Algebra, Albrecht Beutelspacher}\\

Die Darstellung der Permutation als Produkt disjunkter Zyklen erwies sich als günstig,
denn nun kann das Problem in folgende zwei Teile aufgebrochen werden.
Der erste ist, die Container eines Zyklus an die richtige Stelle zu bringen.
Dies lässt sich relativ leicht realisieren, indem der Container am Anfang der Zyklen an die richtige Position gebracht wird,
anschließend der zweite an die richtige, usw., bis der Ausgangspunkt wieder erreicht ist.
Der zweite - etwas schwierige - Teil besteht darin, die Zyklenabarbeitung dort zu unterbrechen, wo eine andere beginnt. \\
Etwas anders ausgedrückt:
Beginnt man an dem Anfang eines Zyklus, können dessen Container ``in einem Stück'' an die richtige Stelle gebracht werden und der Kran anschließend wieder an der Ausgangsposition angelangen.
Wir werden etwas später sehen, dass dadurch tatsächlich auch immer ein optimalen Weg (zumindest innerhalb eines Zyklus) gefunden werden kann.
Durch entsprechend richtige ``Konkatenation'' der einzelnen Befehlsketten für die einzelnen Zyklen lässt sich ein nach dem in der Aufgabenstellung vorgegebenem Gütekriterium optimaler Algorithmus erstellen.
Der durch Ausführung der berechneten Instruktionen abzufahrende Weg ist also minimal.
\subsubsection{Datenstruktur}
Permutationen können in einer indexierten Liste jeder Art (beispielsweise einem Array) gespeichert werden.
Da in der Informatik jedoch indexierte Listen (insbesondere Arrays) meist Indizes aus $[0,n[$ besitzen muss dies beim Zugriff beachtet werden.
Um also die Zahl $p$ zu finden, auf die $i$ durch $perm$ abgebildet wird, gilt $p = perm(i-1)$ jedoch nicht $p = perm(i)$. \\
Es wird außerdem noch eine einfache Datenstruktur benötigt, um das Gleis mit Containerstellplätzen und Waggons abzubilden. \\
Diese ....
% Zyklen
\subsubsection{Ergebnisoptimaler Algorithmus}
\paragraph{Entwurf}
Der Entwurf dieses Algorithmus' ergibt sich aus den obigen Überlegungen. Zunächst wird die Zerlegung in disjunkte Zyklen berechnet.
Hierfür wird folgende Hilfsfunktion zur Berechnung \emph{eines} Zyklus' verwendet.
Wichtig ist hierbei zu beachten, dass die Waggonnummer an der Stelle |idx| durch |perm(idx-1)| dargestellt wird.
\lstset{language=Scala}
\lstset{basicstyle=\small}
\begin{lstlisting}
def cycle(perm: Seq[Int], start: Int): List[Int] = {
  def step(idx: Int): List[Int] =
    if(start == idx) Nil
    else idx :: step(perm(idx - 1))
  start :: step(perm(start-1))
}
\end{lstlisting}
Salopp gesagt, hangelt man sich so lange - bei einem Startindex beginnend - durch die Permutation, bis man wieder beim Anfangswert ankommt.\\
Nun lässt sich auch recht einfach ein Algorithmus zum Finden der disjunkten Zyklen einer Permutation p angeben.
Die folgend dargestellte rekursive Funktion |cyclesOf| liefert eine Liste von disjunkten Zyklen (also eine Liste von Listen von Zahlen)
die die Permutation darstellen. Um disjunkte Zyklen zu finden, müssen sich jeweils alle bisher abgearbeiteten Zahlen gemerkt werden.
Dies erfolgt in einem |Set| (standardmäßig ein |HashSet| in Scala). \\
In jedem Rekursionsschritt wird zunächst der neue Startwert |start| gesucht.
Der Startwert ist die erste Zahl von $1..n$ die noch nicht abgearbeitet wurde (also nicht in |ready| enthalten ist).
Anschließend wird der neue Zyklus |newCycle| mit der Hilfsfunktion |cycle| berechnet.
Dann wird die neue Menge aller abgearbeiteten Zahlen |newReady| gebildet, indem alle Zahlen aus |newCycle| in |ready| eingefügt werden.
Zuletzt erfolgt der rekursive Aufruf, wobei |newCycle| vor den rekursiv berechneten Zyklen gespeichert wird.
% TODO: Wording.
Die Rekursion wird abgebrochen, sobald alle Zahlen abgearbeitet wurden. Dies lässt sich daran erkennen,
dass die Länge der Permutation gleich der Anzahl der abgearbeiteten Zahlen sind. \\
\lstset{language=Scala}
\lstset{basicstyle=\small}
\begin{lstlisting}
def cyclesOf(perm: Seq[Int], ready: Set[Int]): List[List[Int]] =
  if(ready.size == perm.length) Nil
  else {
    val start = (1 to perm.length) find (i => !ready.contains(i))
    val newCycle = cycle(perm, start)
    val newReady = ready ++ newCycle
    newCycle :: cyclesOf(perm, newReady)
  }
\end{lstlisting}

\paragraph{Optimale Ergebnisse}
\label{opt_res}
Dieser Algorithmus liefert bereits optimale Ergebnisse im Sinne des Gütekriteriums der Aufgabenstellung
Um dies zu zeigen, wird zunächst bewiesen, dass die Zyklen richtig gefunden werden. \\
Zunächst wird die Hilfsfunktion |step| der Funktion |cycle| auf Korrektheit geprüft. Da es sich um eine rekursive Funktion handelt, bietet sich hier Induktion an.
Der Beweis, das die Hilfsfunktion |step| zu einer gegebenen Permutation $perm: [0,n[ \rightarrow [1,n]$, einem Start- und Endwert |start| und einem Index |idx|
eine Liste von Zahlen mit Länge n liefert, für die folgendes gilt. ... \\
Induktionsanfang:

... \\
Im folgenden können wir uns also der Korrektheit von |cycle| sicher sein. 
... \\
Anschließend zeigen wir die Optimalheit vom eigentlichem Algorithmus, die Berechnung der Instruktionen.

\paragraph{Laufzeitverhalten}
% O(c*n)
Zunächst wird das Laufzeitverhalten des Algorithmus zum Finden der Zyklen analysiert.
|cyclesOf| berechnet in jedem Schritt den neuen Startwert |start|.
Dazu wird die Folge 1 bis zur Permutationslänge traversiert bis ein Wert gefunden wird der noch nicht abgearbeitet - sprich in |ready| enthalten - ist.
Nimmt man an, dass das Prüfen auf Enthaltensein konstanten Zeitaufwand darstellt (Bsp. bei Verwendung eines |HashSet|s), dann ergibt dies insgesamt eine Komplexität von $O(n)$.
Die Berechnung eines Zyklus benötigt höchstens die Traversierung der Permutation, also ebenfalls $O(n)$. %TODO: Genauer!
Anschließend werden die Zahlen, die im Zyklus enthalten sind, in |ready| eingefügt. Unter Annahme, dass wieder ein |HashSet| verwendet wird, ergibt das eine Komplexität von $O(n)$.
Anschließend erfolgt der rekursive Aufruf. Sei $c$ die Anzahl der Zyklen, dann wird |cyclesOf| $c$-mal aufgerufen.
Die Laufzeitkomplexität zur Finden der Zyklen ist also $O(c \cdot n)$. \\

\subsubsection{Optimaler Algorithmus} %Erweiterung!
Das Laufzeitverhalten von $O(c \cdot n)$ ist zwar bereits recht gut, da die Anzahl der Zyklen im Normalfall nicht linear mit $n$ steigen.
(Eine zufällig erzeugte Permutation mit $10^7$ Elementen hat meist weniger als 20 Zyklen)% TODO: Beleg
Der Worstcase bei $n/2$ Zyklen führt jedoch zu einer Worstcase-Komplexität von $O(n^2)$. \\
Deshalb soll als Erweiterung die Laufzeitkomplexität weiter verringert werden. \\
Außerdem sind die Algorithmen, wie sie oben angegeben sind, nicht tail-recursive.
Das heißt bei jedem rekursivem Aufruf wird ein neuer Stack-frame allokiert.
In der Praxis heißt dies, dass nur eine Rekursionstiefe von höchstens 10000 möglich ist.

\paragraph{Optimale Ergebnisse}
Wie oben (in \ref{opt_res}) bereits gezeigt, können aus korrekten, sortierten Zyklen Instruktionen, die einen optimalen Weg für den Kran liefern, berechnet werden.
Deshalb muss hier lediglich noch gezeigt werden, dass der neue Algorithmus wiederum korrekte und sortierte Zyklen berechnet. \\

\paragraph{Optimale Laufzeitkomplexität}
... \\
Da jeder Container auf einen Waggon gebracht werden muss, muss für jeden Container mindestens ein Befehl erzeugt werden.
Bei $n$ Container sind dies also $n$ Befehle. Das setzt einen Algorithmus mit einer Laufzeitkomplexität von mindestens $O(n)$ voraus.
Der erstellte Algorithmus hat also \textbf{optimale Laufzeitkomplexität}.

% TODO?: Concurrent Algorithm.
\subsection{Implementierung}
Die Implementierung gliedert sich folgendermaßen.
\begin{description}
 \item[Utils] hilfreiche Methoden, unter anderem zur Zyklenfindung.
 \item[SlowUtils] wie Utils, bloß werden die zuerst vorgestellten, langsameren Funktionen zur Zyklenfindung benutzt.
 \item[FastAlgorithm]
 \item[SlowAlgorithm]
\end{description}
\subsubsection{``SlowAlgorithm''}
\subsubsection{``FastAlgorithm''}
\subsubsection{Randomisierte Permutationen}

\newpage
\subsection{Programmabläufe}
\begin{flushright}
  \begin{scriptsize}
  \emph{Bemerkung:} Die Ausgaben der Konsole wurden per Hand nachformatiert zwecks besserem Einbetten in den Textfluss.
  \end{scriptsize}
\end{flushright}
\paragraph{Beispiel aus der Aufgabenstellung}
Das Folgende zeigt den Ablauf der sich bei Eingabe des Beispiels aus der Aufgabestellung ergibt. \\
Zunächst wird die Permutation erzeugt und in |perm| gespeichert.
\begin{lstlisting}
scala> val perm = Seq(4,3,2,1)               
perm: Seq[Int] = List(4, 3, 2, 1)
\end{lstlisting}
Anschließend werden die Instruktionen erzeugt und in |instrs| gespeichert.
\begin{lstlisting}
scala> val instrs = FastAlgorithm compute perm
instrs: Seq[de.voodle.tim.bwinf.container.Instruction] =
  Queue(TakeCon, MoveRight(1), Rotate, TakeCon, Rotate, PutCon,
        Rotate,  MoveRight(1), Rotate, PutWag,
        TakeCon, MoveLeft(1),  Rotate, PutWag,
        TakeCon, MoveRight(2), Rotate, PutWag,
        TakeCon, MoveLeft(3),  Rotate, PutWag, TakeCon)
\end{lstlisting}
Nun wird eine |Maschine| erzeugt, die die Instruktionen ausführen kann.
\begin{lstlisting}
scala> val maschine = new Maschine(new Gleis(perm),true)
maschine: de.voodle.tim.bwinf.container.Maschine = 
Container: 4 3 2 1
Waggons:   _ _ _ _
\end{lstlisting}
Zuletzt soll die Maschine die Instruktionen interpretieren.
\begin{lstlisting}
scala> maschine interpret instrs                        
1 2 3 4
4 3 2 1
-->
  -->
  <--
  ---->
<------
res0: de.voodle.tim.bwinf.container.Gleis = 
Container: _ _ _ _
Waggons:   1 2 3 4
\end{lstlisting}
Bemerkenswert ist hier, dass der erstellte Algorithmus in diesem Fall exakt den gleichen Weg liefert wie im Beispiel der Aufgabenstellung angegeben.
Es gibt noch verschiedene andere Wege.
Beispielsweise kann das Prüfen auf überlappende Zyklen erst beim Zurückfahren geprüft werden,
wodurch sich z.B. einer der folgender Ablauf ergeben könnte.
\begin{lstlisting}                   
1 2 3 4		1 2 3 4
4 3 2 1		4 3 2 1
------>		------>
    <--		  <----
  <--		  -->
  -->		  <--
<----		<--
\end{lstlisting}
\newpage
\paragraph{Zufällig erzeugte Permutation}
Ein nächstes - etwas größeres Beispiel ergibt sich aus zufälliger Erzeugung einer Permutation der Länge 20.
Hierbei wird die Hilfsfunktion |randPerm| des Moduls |Utils| aufgerufen und das Ergebnis wie vorher in |perm| gespeichert.
\begin{lstlisting}
scala> val perm = Utils randPerm 20
perm: Array[Int] = Array(20, 11, 2, 8,  1, 16, 10, 17, 19, 14,
                          5, 12, 9, 3, 13, 15, 18,  4,  7,  6)
\end{lstlisting}
Anschließend werden wieder die Instruktionen mit der Funktion |compute| des Moduls |FastAlgorithm| berechnet und in |instrs| gespeichert.
\begin{lstlisting}
scala> val instrs = FastAlgorithm compute perm
instrs: Seq[de.voodle.tim.bwinf.container.Instruction] =
  Queue(TakeCon, MoveRight(3),  Rotate, TakeCon, Rotate, PutCon,
	Rotate,  MoveRight(4),  Rotate, PutWag,
	TakeCon, MoveRight(4),  Rotate, TakeCon, Rotate, PutCon,
	Rotate,  MoveLeft(0),   Rotate, PutWag,
	TakeCon, MoveRight(5),  Rotate, PutWag,
	TakeCon, MoveRight(1),  Rotate, PutWag, T...
\end{lstlisting}
Zuletzt wird wieder eine |Maschine| |maschine| erzeugt um die Instruktionen zu interpretieren.
\begin{lstlisting}
scala> val maschine = new Maschine(new Gleis(perm),true)      
maschine: de.voodle.tim.bwinf.container.Maschine = 
Container: 20 11 2 8 1 16 10 17 19 14 5 12 9 3 13 15 18 4 7 6
Waggons:    _  _ _ _ _  _  _  _  _  _ _  _ _ _  _  _  _ _ _ _

scala> maschine interpret instrs
 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
20 11  2  8  1 16 10 17 19 14  5 12  9  3 13 15 18  4  7  6
--------->
         ------------>
                     ------------>
                                 <
                                 --------------->
                                                --->
         <------------------------------------------
         ------------------------------------------------>
               <------------------------------------------
               ------------------------------>
                                          <---
                                    <------
                        <------------
                        ------------------------------>
                  <------------------------------------
                  --------->
                           ------------>
      <---------------------------------
   <---
   --------------------------->
            <------------------
<------------
res0: de.voodle.tim.bwinf.container.Gleis = 
Container: _ _ _ _ _ _ _ _ _  _  _  _  _  _  _  _  _  _  _  _
Waggons:   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
\end{lstlisting}
\emph{TODO:} Interpretation!
\paragraph{Demonstration der Skalierbarkeit}
Nun soll die Skalierbarkeit demonstriert werden,
die als Erweiterung in Form von Tail-rekursiven Funktionen und linearer Laufzeitkomplexität implementiert wurde.\\
Hierfür erzeugen wir eine zufällige Permutation von 6,4 Millionen ($6,4 * 10^6$) Zahlen, die unsere Container darstellt.
Anschließend werden wie oben auch, die Instruktionen berechnet und interpretiert. \\
Für Demonstrationszwecke wird außerdem die benötigte Zeit für jeden Schritt berechnet.
Dies hat nicht das Ziel genaue Benchmarkwerte zu liefern, sondern vielmehr einen Anhaltspunkt für das Laufzeitverhalten.
Hierfür wurde ein kleines Scala Programm geschrieben, zu finden im Modul |Utils|.
\\
Nun wird zunächst das Programm ausgeführt. (Die Permutation wird nicht ausgegeben, um Platz zu sparen.)
\begin{lstlisting}
scala> val verified = Utils demonstrate 6400000
Time used for computing Cycles: 30093
Number of cycles: 18
Time used: 110879
Time used interpreting: 10639
verified: Boolean = true
\end{lstlisting}
Interessant ist hier die Beobachtung, dass es nur 18 Zyklen gibt, bei einer Permutationslänge von $~10^7$.
TODO: !!! Interpret more !!!

\subsection{Programmnutzung}
\subsection{Programmtext}