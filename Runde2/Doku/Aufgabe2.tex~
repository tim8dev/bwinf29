\section{Zweite bearbeitete Aufgabe: (2) Containerklamüsel}
\subsection{Lösungsidee}
\subsubsection{Vorüberlegungen}
Die Anordnung der Waggons zu den Container ist eine bijektive Abbildung von $[1,n]$ nach $[1,n]$, sprich, eine Permutation der Menge $[1,n]$.
Jede Permutation lässt sich als Folge von disjunkten Zyklen darstellen. \\ %TODO: CITE!
``Eine Permutation $\pi$ einer Menge wird \emph{Zyklus} genannt, falls - grob gesprochen - die Elemente, die von $\pi$ bewegt werden,
zyklisch vertauscht werden. Genauer gesagt: Eine Permutation $\pi$ heißt zyklisch,
falls es ein $ i \in X$ und eine natürliche Zahl $k$ gibt, so dass die folgenden drei Bedingungen gelten:
\begin{enumerate}
 \item $\pi^k(i) = i$,
 \item die Elemente $i,\pi(i),\pi^2(i),\dots,\pi^{k-1}(i)$ sind paarweise verschieden,
 \item jedes Element, das verschieden von $i,\pi(i),\pi^2(i),\dots,\pi^{k-1}(i) (=i)$ ist, wird von $\pi$ fest gelassen.
\end{enumerate}
Die kleinste natürliche Zahl k mit obiger Eigenschaft wird die \emph{Länge} des Zyklus $\pi$ genannt.
Ein Zyklus der Länge k heißt auch k-Zyklus. Wir schreiben dann \[\pi=(i\;\pi(i)\;\pi^2(i) \; \dots \;\pi^{k-1}(i)).\]
[..]
\paragraph{Darstellung einer Permutation als Produkt disjunker Zyklen.}
\emph{Jede Permutation kann als Produkt zyklischer Permutationen geschrieben werden, von denen keine zwei ein Element gemeinsam haben.}\\
\emph{Das heißt: Zu jedem $\pi \in S_n$ gibt es zyklische Permutationen $\zeta_1,\dots,\zeta_s \in S_n$,
so dass folgendes Eigenschaften erfüllt sind: \\
 - $\pi=\zeta_1\cdot \zeta_2 \cdot \ldots \cdot \zeta_s$ \\
 - kein Element aus X, das als Komponente in $\zeta_i$ vorkommt, kommt in $\zeta_j$ vor ($i,j=1,\dots,n, i \neq j$).
(Das bedeuted: Wenn ein Element $x \in X$ in einem Zyklus $\zeta_i$ ``vorkommt'',
 so wird $x$ von jedem anderen Zyklus $\zeta_j \: (j \neq i)$ fest gelassen.)
}''\footnote{Definitionen, Sätze und Erklärung übernommen aus Lineare Algebra, Albrecht Beutelspacher}\\
Dies erwies sich als günstig, denn nun kann das Problem in folgende zwei Teile aufgebrochen werden.
Der erste ist, die Container eines Zyklus an die richtige Stelle zu bringen.
Dies lässt sich relativ leicht realisieren, indem der Container am Anfang der Zyklen an die richtige Position gebracht wird, anschließend der - dortige - zweite an die richtige, usw., bis der Ausgangspunkt wieder erreicht ist.
Der zweite - etwas schwierige - Teil besteht darin, die Zyklenabarbeitung dort zu unterbrechen, wo eine andere beginnt. \\
Etwas anders ausgedrückt:
Beginnt man an dem Anfang eines Zyklus, können dessen Container ``in einem Stück'' an die richtige Stelle gebracht werden und der Kran anschließend wieder an der Ausgangsposition angelangen.
Wir werden etwas später sehen, dass dadurch tatsächlich auch immer ein optimalen Weg (zumindest innerhalb eines Zyklus) gefunden werden kann.
Durch entsprechend richtige ``Konkatenation'' der einzelnen Befehlsketten für die einzelnen Zyklen lässt sich ein insgesamt richtiger Algorithmus erstellen.
\subsubsection{Datenstruktur}
Permutationen können in jeder indexierten Liste gespeichert werden.
Da in der Informatik jedoch indexierte Listen (insbesondere Arrays) Indizes aus $[0,n[$ besitzen muss dies beim Zugriff beachtet werden.
Um also die Zahl $p$ zu finden, auf die $i$ durch $perm$ abgebildet wird, gilt $p = perm(i-1)$ und nicht $p = perm(i)$. \\
Es wird außerdem noch eine einfache Datenstruktur benötigt, um das Gleis mit Containerstellplätzen und Waggons abzubilden. \\
Diese ....
% Zyklen
\subsubsection{Ergebnisoptimaler Algorithmus}
\paragraph{Entwurf}
Der Entwurf dieses Algorithmus' ergibt sich aus den obigen Überlegungen. Zunächst wird die Zerlegung in disjunkte Zyklen berechnet.
Hierfür wird folgende Hilfsfunktion zur Berechnung \emph{eines} Zyklus' verwendet.
Wichtig ist hierbei zu beachten, dass die Waggonnummer an der Stelle |idx| durch |perm(idx-1)| dargestellt wird.
\lstset{language=Scala}
\lstset{basicstyle=\small}
\begin{lstlisting}
def cycle(perm: Seq[Int], start: Int): List[Int] = {
  def step(idx: Int): List[Int] =
    if(start == idx) Nil
    else idx :: step(perm(idx - 1))
  start :: step(perm(start-1))
}
\end{lstlisting}
Salopp gesagt, hangelt man sich so lange - bei einem Startindex beginnend - durch die Permutation, bis man wieder beim Anfangswert ankommt.\\
Nun lässt sich auch recht einfach ein Algorithmus zum Finden der disjunkten Zyklen einer Permutation p angeben.
Die folgend dargestellte rekursive Funktion |cyclesOf| liefert eine Liste von disjunkten Zyklen (also eine Liste von Listen von Zahlen)
die die Permutation darstellen. Um disjunkte Zyklen zu finden, müssen sich jeweils alle bisher abgearbeiteten Zahlen gemerkt werden.
Dies erfolgt in einem |Set| (standardmäßig ein |HashSet| in Scala). \\
In jedem Rekursionsschritt wird zunächst der neue Startwert |start| gesucht.
Der Startwert ist die erste Zahl von $1..n$ der noch nicht abgearbeitet wurde (also nicht in |ready| enthalten ist).
Anschließend wird der neue Zyklus |newCycle| mit Hilfe von |cycle| berechnet.
Dann wird die neue Menge aller abgearbeiteten Zahlen |newReady| gebildet, indem alle Zahlen aus |newCycle| in |ready| eingefügt werden.
Zuletzt erfolgt der rekursive Aufruf, wobei |newCycle| vor die rekursiv berechneten Zyklen gesetzt wird.
% TODO: Wording.
Die Rekursion wird abgebrochen, sobald alle Zahlen abgearbeitet wurden. Dies lässt sich daran erkennen,
dass die Länge der Permutation gleich der Anzahl der abgearbeiteten Zahlen sind. \\
\lstset{language=Scala}
\lstset{basicstyle=\small}
\begin{lstlisting}
def cyclesOf(perm: Seq[Int], ready: Set[Int]): List[List[Int]] =
  if(ready.size == perm.length) Nil
  else {
    val start = (1 to perm.length) find (i => !ready.contains(i))
    val newCycle = cycle(perm, start)
    val newReady = ready ++ newCycle
    newCycle :: cyclesOf(perm, newReady)
  }
\end{lstlisting}

\paragraph{Optimale Ergebnisse}
Dieser Algorithmus liefert bereits optimale Ergebnisse. Um dies zu zeigen, wird zunächst bewiesen, dass die Zyklen richtig gefunden werden. \\
Zunächst wird die Hilfsfunktion |step| der Funktion |cycle| auf Korrektheit geprüft. Da es sich um eine rekursive Funktion handelt, bietet sich hier Induktion an.
Der Beweis, das die Hilfsfunktion |step| zu einer gegebenen Permutation $perm: [0,n[ \rightarrow [1,n]$, einem Start- und Endwert |start| und einem Index |idx|
eine Liste von Zahlen mit Länge n liefert, für die folgendes gilt. ... \\
Induktionsanfang:

... \\
Im folgenden können wir uns also der Korrektheit von |cycle| sicher sein. 
... \\
Anschließend zeigen wir die Optimalheit vom eigentlichem Algorithmus, die Berechnung der Instruktionen.

\paragraph{Laufzeitverhalten}
% O(c*n)
Zunächst wird das Laufzeitverhalten des Algorithmus zum Finden der Zyklen analysiert.
|cyclesOf| berechnet in jedem Schritt den neuen Startwert |start|.
Dazu wird die Folge 1 bis zur Permutationslänge traversiert bis ein Wert gefunden wird der noch nicht abgearbeitet - sprich in |ready| enthalten - ist.
Nimmt man an, dass das Prüfen auf Enthaltensein konstanten Zeitaufwand darstellt (Bsp. bei Verwendung eines |HashSet|s), dann ergibt dies insgesamt eine Komplexität von $O(n)$.
Die Berechnung eines Zyklus benötigt höchstens die Traversierung der Permutation, also ebenfalls $O(n)$. %TODO: Genauer!
Anschließend werden die Zahlen, die im Zyklus enthalten sind, in |ready| eingefügt. Unter Annahme, dass wieder ein |HashSet| verwendet wird, ergibt das eine Komplexität von $O(n)$.
Anschließend erfolgt der rekursive Aufruf. Sei $c$ die Anzahl der Zyklen, dann wird |cyclesOf| $c$-mal aufgerufen.
Die Laufzeitkomplexität zur Finden der Zyklen ist also $O(c \cdot n)$. \\

\subsubsection{Optimaler Algorithmus} %Erweiterung!
Das Laufzeitverhalten von $O(c \cdot n)$ ist zwar bereits recht gut, da die Anzahl der Zyklen im Normalfall nicht linear mit $n$ steigen.
(Eine zufällig erzeugte Permutation mit $10^7$ Elementen hat meist weniger als 20 Zyklen)% TODO: Beleg
Der Worstcase bei $n/2$ Zyklen führt zu einer Worstcase-Komplexität von $O(n²)$. \\
Als Erweiterung soll die Laufzeitkomplexität weiter verringert werden. \\
Außerdem sind die Algorithmen, wie sie oben angegeben sind, nicht tail-recursive.
Das heißt bei jedem rekursivem Aufruf wird ein neuer Stack-frame allokiert.
In der Praxis heißt dies, dass nur eine Rekursionstiefe von höchstens 10000 möglich ist.

\paragraph{Optimale Ergebnisse}
Da oben %TODO: Ref
bereits gezeigt wurde, dass aus korrekten Zyklen Instruktionen, die einen optimalen Weg für den Kran liefern, berechnet werden.
Muss hier nur noch gezeigt werden, dass wiederum korrekte Zyklen berechnet werden. \\

\paragraph{Optimale Laufzeitkomplexität}
... \\
Da jeder Container auf einen Waggon gebracht werden muss, muss für jeden Container mindestens ein Befehl erzeugt werden.
Bei $n$ Container sind dies also $n$ Befehle. Das setzt einen Algorithmus mit einer Laufzeitkomplexität von mindestens $O(n)$ voraus.
Der erstellte Algorithmus hat also \textbf{optimale Laufzeitkomplexität}.

% TODO?: Concurrent Algorithm.
\subsection{Implementation}
\newpage
\subsection{Programmabläufe}
\paragraph{Beispiel aus der Aufgabenstellung}
Das Folgende zeigt den Ablauf, bei Eingabe des Beispiels aus der Aufgabestellung. \\
Zunächst wird die Permutation in |perm| gespeichert.
\begin{lstlisting}
scala> val perm = Seq(4,3,2,1)               
perm: Seq[Int] = List(4, 3, 2, 1)
\end{lstlisting}
Anschließend werden die Instruktionen erzeugt und in |instrs| gespeichert.
\begin{lstlisting}
scala> val instrs = FastAlgorithm compute perm
instrs: Seq[de.voodle.tim.bwinf.container.Instruction] =
  Queue(TakeCon, MoveRight(1), Rotate, TakeCon, Rotate, PutCon,
        Rotate,  MoveRight(1), Rotate, PutWag,
        TakeCon, MoveLeft(1),  Rotate, PutWag,
        TakeCon, MoveRight(2), Rotate, PutWag,
        TakeCon, MoveLeft(3),  Rotate, PutWag, TakeCon)
\end{lstlisting}
Nun wird eine |Maschine| erzeugt, die die Instruktionen ausführen kann.
\begin{lstlisting}
scala> val maschine = new Maschine(new Gleis(perm),true)
maschine: de.voodle.tim.bwinf.container.Maschine = 
Container: 4 3 2 1
Waggons:   _ _ _ _
\end{lstlisting}
Zuletzt soll die Maschine die Instruktionen interpretieren.
\begin{lstlisting}
scala> maschine interpret instrs                        
1 2 3 4
4 3 2 1
-->
  -->
  <--
  ---->
<------
res0: de.voodle.tim.bwinf.container.Gleis = 
Container: _ _ _ _
Waggons:   1 2 3 4
\end{lstlisting}
Bemerkenswert ist hier, dass dies genau den gleichen Weg liefert wie im Beispiel der Aufgabenstellung angegeben.
(Obwohl es viele verschieden optimale Wege gibt, bspsweise.....)\\
Ein nächtes - etwas größeres Beispiel:
\begin{lstlisting}

\end{lstlisting}

\subsection{Programmtext}
\subsection{Programmnutzung}